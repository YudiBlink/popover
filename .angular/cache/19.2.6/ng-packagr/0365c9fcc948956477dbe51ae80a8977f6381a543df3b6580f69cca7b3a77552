{"hash":"d824b6883bb7642972b23218ef112925825b37da4863511dddfcb3567ceb29d0","fesm2022":[{"exports":["MdePopover","MdePopoverModule","MdePopoverTarget","MdePopoverTrigger","transformPopover"],"facadeModuleId":"D:\\Blink\\app-test-popover\\popover\\dist\\material-extended\\mde\\esm2022\\material-extended-mde.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["D:/Blink/app-test-popover/popover/dist/material-extended/mde/esm2022/lib/popover/popover-errors.mjs","D:/Blink/app-test-popover/popover/dist/material-extended/mde/esm2022/lib/popover/popover-animations.mjs","D:/Blink/app-test-popover/popover/dist/material-extended/mde/esm2022/lib/popover/popover.mjs","D:/Blink/app-test-popover/popover/dist/material-extended/mde/esm2022/lib/popover/popover-trigger.mjs","D:/Blink/app-test-popover/popover/dist/material-extended/mde/esm2022/lib/popover/popover-target.mjs","D:/Blink/app-test-popover/popover/dist/material-extended/mde/esm2022/lib/popover/popover-module.mjs","D:/Blink/app-test-popover/popover/dist/material-extended/mde/esm2022/lib/popover/popover-interfaces.mjs","D:/Blink/app-test-popover/popover/dist/material-extended/mde/esm2022/public_api.mjs","D:\\Blink\\app-test-popover\\popover\\dist\\material-extended\\mde\\esm2022\\material-extended-mde.mjs"],"name":"material-extended-mde","type":"chunk","dynamicImports":[],"fileName":"material-extended-mde.mjs","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["*","EventEmitter","TemplateRef","ViewEncapsulation","ChangeDetectionStrategy","Component","ViewChild","Output","Input","HostBinding","Directive","Optional","HostListener","NgModule"],"@angular/common":["*","CommonModule"],"@angular/cdk/overlay":["OverlayConfig","*","OverlayModule"],"@angular/cdk/coercion":["coerceBooleanProperty"],"@angular/cdk/keycodes":["ESCAPE"],"@angular/animations":["trigger","state","transition","style","animate"],"@angular/cdk/a11y":["*","isFakeMousedownFromScreenReader","A11yModule"],"@angular/cdk/portal":["TemplatePortal"],"rxjs":["Subject"],"rxjs/operators":["takeUntil"],"@angular/cdk/bidi":["*"]},"imports":["@angular/core","@angular/common","@angular/cdk/overlay","@angular/cdk/coercion","@angular/cdk/keycodes","@angular/animations","@angular/cdk/a11y","@angular/cdk/portal","rxjs","rxjs/operators","@angular/cdk/bidi"],"modules":{"D:/Blink/app-test-popover/popover/dist/material-extended/mde/esm2022/lib/popover/popover-errors.mjs":{"code":"/**\n * Throws an exception for the case when popover trigger doesn't have a valid mde-popover instance\n */\nfunction throwMdePopoverMissingError() {\n    throw Error(`mde-popover-trigger: must pass in an mde-popover instance.\r\n\r\n    Example:\r\n      <mde-popover #popover=\"mdePopover\"></mde-popover>\r\n      <button [mdePopoverTriggerFor]=\"popover\"></button>`);\n}\n/**\n * Throws an exception for the case when popover's mdePopoverPositionX value isn't valid.\n * In other words, it doesn't match 'before' or 'after'.\n */\nfunction throwMdePopoverInvalidPositionX() {\n    throw Error(`mdePopoverPositionX value must be either 'before' or after'.\r\n      Example: <mde-popover mdePopoverPositionX=\"before\" #popover=\"mdePopover\"></mde-popover>`);\n}\n/**\n * Throws an exception for the case when popover's mdePopoverPositionY value isn't valid.\n * In other words, it doesn't match 'above' or 'below'.\n */\nfunction throwMdePopoverInvalidPositionY() {\n    throw Error(`mdePopoverPositionY value must be either 'above' or below'.\r\n      Example: <mde-popover mdePopoverPositionY=\"above\" #popover=\"mdePopover\"></mde-popover>`);\n}","originalLength":3412,"removedExports":[],"renderedExports":["throwMdePopoverMissingError","throwMdePopoverInvalidPositionX","throwMdePopoverInvalidPositionY"],"renderedLength":1112},"D:/Blink/app-test-popover/popover/dist/material-extended/mde/esm2022/lib/popover/popover-animations.mjs":{"code":"/**\n * Below are all the animations for the md-popover component.\n * Animation duration and timing values are based on AngularJS Material.\n */\n/**\n * This animation controls the popover panel's entry and exit from the page.\n *\n * When the popover panel is added to the DOM, it scales in and fades in its border.\n *\n * When the popover panel is removed from the DOM, it simply fades out after a brief\n * delay to display the ripple.\n */\nconst transformPopover = trigger('transformPopover', [\n    state('enter', style({\n        opacity: 1,\n        transform: `scale(1)`\n    })),\n    transition('void => *', [\n        style({\n            opacity: 0,\n            transform: `scale(0)`\n        }),\n        animate(`200ms cubic-bezier(0.25, 0.8, 0.25, 1)`)\n    ]),\n    transition('* => void', [\n        animate('50ms 100ms linear', style({ opacity: 0 }))\n    ])\n]);","originalLength":3408,"removedExports":[],"renderedExports":["transformPopover"],"renderedLength":859},"D:/Blink/app-test-popover/popover/dist/material-extended/mde/esm2022/lib/popover/popover.mjs":{"code":"const _c0 = [\"*\"];\nfunction MdePopover_ng_template_0_div_1_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 3);\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r1.popoverArrowStyles);\n} }\nfunction MdePopover_ng_template_0_Template(rf, ctx) { if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 0);\n    i0.ɵɵlistener(\"keydown\", function MdePopover_ng_template_0_Template_div_keydown_0_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1._handleKeydown($event)); })(\"click\", function MdePopover_ng_template_0_Template_div_click_0_listener() { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.onClick()); })(\"mouseover\", function MdePopover_ng_template_0_Template_div_mouseover_0_listener() { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.onMouseOver()); })(\"mouseleave\", function MdePopover_ng_template_0_Template_div_mouseleave_0_listener() { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.onMouseLeave()); });\n    i0.ɵɵtemplate(1, MdePopover_ng_template_0_div_1_Template, 1, 1, \"div\", 1);\n    i0.ɵɵelementStart(2, \"div\", 2);\n    i0.ɵɵprojection(3);\n    i0.ɵɵelementEnd()();\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"mde-popover-overlap\", ctx_r1.overlapTrigger);\n    i0.ɵɵproperty(\"ngClass\", ctx_r1._classList)(\"ngStyle\", ctx_r1.popoverPanelStyles)(\"@.disabled\", ctx_r1.disableAnimation)(\"@transformPopover\", \"enter\");\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", !ctx_r1.overlapTrigger);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngStyle\", ctx_r1.popoverContentStyles)(\"cdkTrapFocus\", ctx_r1.focusTrapEnabled)(\"cdkTrapFocusAutoCapture\", ctx_r1.focusTrapAutoCaptureEnabled);\n} }\nclass MdePopover {\n    /** Position of the popover in the X axis. */\n    get positionX() { return this._positionX; }\n    set positionX(value) {\n        if (value !== 'before' && value !== 'after') {\n            throwMdePopoverInvalidPositionX();\n        }\n        this._positionX = value;\n        this.setPositionClasses();\n    }\n    /** Position of the popover in the Y axis. */\n    get positionY() { return this._positionY; }\n    set positionY(value) {\n        if (value !== 'above' && value !== 'below') {\n            throwMdePopoverInvalidPositionY();\n        }\n        this._positionY = value;\n        this.setPositionClasses();\n    }\n    /** Popover trigger event */\n    get triggerEvent() { return this._triggerEvent; }\n    set triggerEvent(value) { this._triggerEvent = value; }\n    /** Popover scroll strategy */\n    get scrollStrategy() { return this._scrollStrategy; }\n    set scrollStrategy(value) { this._scrollStrategy = value; }\n    /** Popover enter delay */\n    get enterDelay() { return this._enterDelay; }\n    set enterDelay(value) { this._enterDelay = value; }\n    /** Popover leave delay */\n    get leaveDelay() { return this._leaveDelay; }\n    set leaveDelay(value) { this._leaveDelay = value; }\n    /** Popover overlap trigger */\n    get overlapTrigger() { return this._overlapTrigger; }\n    set overlapTrigger(value) { this._overlapTrigger = value; }\n    /** Popover target offset x */\n    get targetOffsetX() { return this._targetOffsetX; }\n    set targetOffsetX(value) { this._targetOffsetX = value; }\n    /** Popover target offset y */\n    get targetOffsetY() { return this._targetOffsetY; }\n    set targetOffsetY(value) { this._targetOffsetY = value; }\n    /** Popover arrow offset x */\n    get arrowOffsetX() { return this._arrowOffsetX; }\n    set arrowOffsetX(value) { this._arrowOffsetX = value; }\n    /** Popover arrow width */\n    get arrowWidth() { return this._arrowWidth; }\n    set arrowWidth(value) { this._arrowWidth = value; }\n    /** Popover arrow color */\n    get arrowColor() { return this._arrowColor; }\n    set arrowColor(value) { this._arrowColor = value; }\n    /**\n     * Popover container close on click\n     * default: true\n     */\n    get closeOnClick() { return this._closeOnClick; }\n    set closeOnClick(value) { this._closeOnClick = coerceBooleanProperty(value); }\n    /**\n     * Disable animations of popover and all child elements\n     * default: false\n     */\n    get disableAnimation() { return this._disableAnimation; }\n    set disableAnimation(value) { this._disableAnimation = coerceBooleanProperty(value); }\n    /**\n     * Popover focus trap using cdkTrapFocus\n     * default: true\n     */\n    get focusTrapEnabled() { return this._focusTrapEnabled; }\n    set focusTrapEnabled(value) { this._focusTrapEnabled = coerceBooleanProperty(value); }\n    /**\n     * Popover focus trap auto capture using cdkTrapFocusAutoCapture\n     * default: true\n     */\n    get focusTrapAutoCaptureEnabled() { return this._focusTrapAutoCaptureEnabled; }\n    set focusTrapAutoCaptureEnabled(value) { this._focusTrapAutoCaptureEnabled = coerceBooleanProperty(value); }\n    /**\n     * This method takes classes set on the host md-popover element and applies them on the\n     * popover template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing popover from outside the component.\n     * @param classes list of class names\n     */\n    set panelClass(classes) {\n        if (classes && classes.length) {\n            this._classList = classes.split(' ').reduce((obj, className) => {\n                obj[className] = true;\n                return obj;\n            }, {});\n            this._elementRef.nativeElement.className = '';\n            this.setPositionClasses();\n        }\n    }\n    /**\n     * This method takes classes set on the host md-popover element and applies them on the\n     * popover template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing popover from outside the component.\n     * @deprecated Use `panelClass` instead.\n     */\n    get classList() { return this.panelClass; }\n    set classList(classes) { this.panelClass = classes; }\n    constructor(_elementRef, zone) {\n        this._elementRef = _elementRef;\n        this.zone = zone;\n        this.role = 'dialog';\n        /** Settings for popover, view setters and getters for more detail */\n        this._positionX = 'after';\n        this._positionY = 'below';\n        this._triggerEvent = 'hover';\n        this._scrollStrategy = 'reposition';\n        this._enterDelay = 200;\n        this._leaveDelay = 200;\n        this._overlapTrigger = true;\n        this._disableAnimation = false;\n        this._targetOffsetX = 0;\n        this._targetOffsetY = 0;\n        this._arrowOffsetX = 20;\n        this._arrowWidth = 8;\n        this._arrowColor = 'rgba(0, 0, 0, 0.12)';\n        this._closeOnClick = true;\n        this._focusTrapEnabled = true;\n        this._focusTrapAutoCaptureEnabled = true;\n        /** Config object to be passed into the popover's ngClass */\n        this._classList = {};\n        // TODO: Write comment description\n        /** */\n        this.containerPositioning = false;\n        /** Closing disabled on popover */\n        this.closeDisabled = false;\n        /** Emits the current animation state whenever it changes. */\n        this._onAnimationStateChange = new EventEmitter();\n        /** Event emitted when the popover is closed. */\n        this.close = new EventEmitter();\n        this.setPositionClasses();\n    }\n    ngOnDestroy() {\n        this._emitCloseEvent();\n        this.close.complete();\n    }\n    /** Handle a keyboard event from the popover, delegating to the appropriate action. */\n    _handleKeydown(event) {\n        switch (event.keyCode) {\n            case ESCAPE:\n                this._emitCloseEvent();\n                return;\n        }\n    }\n    /**\n     * This emits a close event to which the trigger is subscribed. When emitted, the\n     * trigger will close the popover.\n     */\n    _emitCloseEvent() {\n        this.close.emit();\n    }\n    /** Close popover on click if closeOnClick is true */\n    onClick() {\n        if (this.closeOnClick) {\n            this._emitCloseEvent();\n        }\n    }\n    /**\n     * TODO: Refactor when @angular/cdk includes feature I mentioned on github see link below.\n     * https://github.com/angular/material2/pull/5493#issuecomment-313085323\n     */\n    /** Disables close of popover when leaving trigger element and mouse over the popover */\n    onMouseOver() {\n        if (this.triggerEvent === 'hover') {\n            this.closeDisabled = true;\n        }\n    }\n    /** Enables close of popover when mouse leaving popover element */\n    onMouseLeave() {\n        if (this.triggerEvent === 'hover') {\n            this.closeDisabled = false;\n            this._emitCloseEvent();\n        }\n    }\n    // TODO: Refactor how styles are set and updated on the component, use best practices.\n    // TODO: If arrow left and right positioning is requested, see if flex direction can be used to work with order.\n    /** Sets the current styles for the popover to allow for dynamically changing settings */\n    setCurrentStyles() {\n        // TODO: See if arrow position can be calculated automatically and allow override.\n        // TODO: See if flex order is a better alternative to position arrow top or bottom.\n        this.popoverArrowStyles = {\n            'right': this.positionX === 'before' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',\n            'left': this.positionX === 'after' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',\n            'border-top': this.positionY === 'below' ?\n                this.arrowWidth + 'px solid ' + this.arrowColor : '0px solid transparent',\n            'border-right': 'undefined' === undefined ?\n                this.arrowWidth + 'px solid ' + this.arrowColor :\n                this.arrowWidth + 'px solid transparent',\n            'border-bottom': this.positionY === 'above' ?\n                this.arrowWidth + 'px solid ' + this.arrowColor :\n                this.arrowWidth + 'px solid transparent',\n            'border-left': 'undefined' === undefined ?\n                this.arrowWidth + 'px solid ' + this.arrowColor :\n                this.arrowWidth + 'px solid transparent',\n        };\n        // TODO: Remove if flex order is added.\n        this.popoverContentStyles = {\n            'padding-top': this.overlapTrigger === true ? '0px' : this.arrowWidth + 'px',\n            'padding-bottom': this.overlapTrigger === true ? '0px' : (this.arrowWidth) + 'px',\n            'margin-top': this.overlapTrigger === false && this.positionY === 'below' && this.containerPositioning === false ?\n                -(this.arrowWidth * 2) + 'px' : '0px'\n        };\n    }\n    /**\n     * It's necessary to set position-based classes to ensure the popover panel animation\n     * folds out from the correct direction.\n     */\n    setPositionClasses(posX = this.positionX, posY = this.positionY) {\n        this._classList['mde-popover-before'] = posX === 'before';\n        this._classList['mde-popover-after'] = posX === 'after';\n        this._classList['mde-popover-above'] = posY === 'above';\n        this._classList['mde-popover-below'] = posY === 'below';\n    }\n    static { this.ɵfac = function MdePopover_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || MdePopover)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone)); }; }\n    static { this.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: MdePopover, selectors: [[\"mde-popover\"]], viewQuery: function MdePopover_Query(rf, ctx) { if (rf & 1) {\n            i0.ɵɵviewQuery(TemplateRef, 5);\n        } if (rf & 2) {\n            let _t;\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);\n        } }, hostVars: 1, hostBindings: function MdePopover_HostBindings(rf, ctx) { if (rf & 2) {\n            i0.ɵɵattribute(\"role\", ctx.role);\n        } }, inputs: { positionX: [0, \"mdePopoverPositionX\", \"positionX\"], positionY: [0, \"mdePopoverPositionY\", \"positionY\"], triggerEvent: [0, \"mdePopoverTriggerOn\", \"triggerEvent\"], scrollStrategy: [0, \"mdePopoverScrollStrategy\", \"scrollStrategy\"], enterDelay: [0, \"mdePopoverEnterDelay\", \"enterDelay\"], leaveDelay: [0, \"mdePopoverLeaveDelay\", \"leaveDelay\"], overlapTrigger: [0, \"mdePopoverOverlapTrigger\", \"overlapTrigger\"], targetOffsetX: [0, \"mdePopoverOffsetX\", \"targetOffsetX\"], targetOffsetY: [0, \"mdePopoverOffsetY\", \"targetOffsetY\"], arrowOffsetX: [0, \"mdePopoverArrowOffsetX\", \"arrowOffsetX\"], arrowWidth: [0, \"mdePopoverArrowWidth\", \"arrowWidth\"], arrowColor: [0, \"mdePopoverArrowColor\", \"arrowColor\"], closeOnClick: [0, \"mdePopoverCloseOnClick\", \"closeOnClick\"], disableAnimation: [0, \"mdePopoverDisableAnimation\", \"disableAnimation\"], focusTrapEnabled: [0, \"mdeFocusTrapEnabled\", \"focusTrapEnabled\"], focusTrapAutoCaptureEnabled: [0, \"mdeFocusTrapAutoCaptureEnabled\", \"focusTrapAutoCaptureEnabled\"], panelClass: [0, \"class\", \"panelClass\"], classList: \"classList\" }, outputs: { close: \"close\" }, exportAs: [\"mdePopover\"], standalone: false, ngContentSelectors: _c0, decls: 1, vars: 0, consts: [[\"role\", \"dialog\", 1, \"mde-popover-panel\", 3, \"keydown\", \"click\", \"mouseover\", \"mouseleave\", \"ngClass\", \"ngStyle\"], [\"class\", \"mde-popover-direction-arrow\", 3, \"ngStyle\", 4, \"ngIf\"], [1, \"mde-popover-content\", 3, \"ngStyle\", \"cdkTrapFocus\", \"cdkTrapFocusAutoCapture\"], [1, \"mde-popover-direction-arrow\", 3, \"ngStyle\"]], template: function MdePopover_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵprojectionDef();\n            i0.ɵɵtemplate(0, MdePopover_ng_template_0_Template, 4, 10, \"ng-template\");\n        } }, dependencies: [i1.NgClass, i1.NgIf, i1.NgStyle, i2.CdkTrapFocus], styles: [\".mde-popover-panel{display:flex;flex-direction:column;max-height:calc(100vh + 48px)}.mde-popover-ripple{position:absolute;inset:0}.mde-popover-below .mde-popover-direction-arrow{position:absolute;bottom:0;width:0;height:0;border-bottom-width:0!important;z-index:99999}.mde-popover-above .mde-popover-direction-arrow{position:absolute;top:0;width:0;height:0;border-top-width:0!important;z-index:99999}.mde-popover-after .mde-popover-direction-arrow{left:20px}.mde-popover-before .mde-popover-direction-arrow{right:20px}\\n\"], encapsulation: 2, data: { animation: [\n                transformPopover\n            ] }, changeDetection: 0 }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MdePopover, [{\n        type: Component,\n        args: [{ selector: 'mde-popover', changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, animations: [\n                    transformPopover\n                ], exportAs: 'mdePopover', standalone: false, template: \"<ng-template>\\r\\n  <div class=\\\"mde-popover-panel\\\" role=\\\"dialog\\\" [class.mde-popover-overlap]=\\\"overlapTrigger\\\"\\r\\n       [ngClass]=\\\"_classList\\\" [ngStyle]=\\\"popoverPanelStyles\\\" (keydown)=\\\"_handleKeydown($event)\\\"\\r\\n       (click)=\\\"onClick()\\\" (mouseover)=\\\"onMouseOver()\\\" (mouseleave)=\\\"onMouseLeave()\\\" [@.disabled]=\\\"disableAnimation\\\"\\r\\n       [@transformPopover]=\\\"'enter'\\\">\\r\\n    <div class=\\\"mde-popover-direction-arrow\\\" [ngStyle]=\\\"popoverArrowStyles\\\" *ngIf=\\\"!overlapTrigger\\\"></div>\\r\\n    <div class=\\\"mde-popover-content\\\" [ngStyle]=\\\"popoverContentStyles\\\" [cdkTrapFocus]=\\\"focusTrapEnabled\\\" [cdkTrapFocusAutoCapture]=\\\"focusTrapAutoCaptureEnabled\\\">\\r\\n      <ng-content></ng-content>\\r\\n    </div>\\r\\n  </div>\\r\\n</ng-template>\\r\\n\", styles: [\".mde-popover-panel{display:flex;flex-direction:column;max-height:calc(100vh + 48px)}.mde-popover-ripple{position:absolute;inset:0}.mde-popover-below .mde-popover-direction-arrow{position:absolute;bottom:0;width:0;height:0;border-bottom-width:0!important;z-index:99999}.mde-popover-above .mde-popover-direction-arrow{position:absolute;top:0;width:0;height:0;border-top-width:0!important;z-index:99999}.mde-popover-after .mde-popover-direction-arrow{left:20px}.mde-popover-before .mde-popover-direction-arrow{right:20px}\\n\"] }]\n    }], () => [{ type: i0.ElementRef }, { type: i0.NgZone }], { role: [{\n            type: HostBinding,\n            args: ['attr.role']\n        }], positionX: [{\n            type: Input,\n            args: ['mdePopoverPositionX']\n        }], positionY: [{\n            type: Input,\n            args: ['mdePopoverPositionY']\n        }], triggerEvent: [{\n            type: Input,\n            args: ['mdePopoverTriggerOn']\n        }], scrollStrategy: [{\n            type: Input,\n            args: ['mdePopoverScrollStrategy']\n        }], enterDelay: [{\n            type: Input,\n            args: ['mdePopoverEnterDelay']\n        }], leaveDelay: [{\n            type: Input,\n            args: ['mdePopoverLeaveDelay']\n        }], overlapTrigger: [{\n            type: Input,\n            args: ['mdePopoverOverlapTrigger']\n        }], targetOffsetX: [{\n            type: Input,\n            args: ['mdePopoverOffsetX']\n        }], targetOffsetY: [{\n            type: Input,\n            args: ['mdePopoverOffsetY']\n        }], arrowOffsetX: [{\n            type: Input,\n            args: ['mdePopoverArrowOffsetX']\n        }], arrowWidth: [{\n            type: Input,\n            args: ['mdePopoverArrowWidth']\n        }], arrowColor: [{\n            type: Input,\n            args: ['mdePopoverArrowColor']\n        }], closeOnClick: [{\n            type: Input,\n            args: ['mdePopoverCloseOnClick']\n        }], disableAnimation: [{\n            type: Input,\n            args: ['mdePopoverDisableAnimation']\n        }], focusTrapEnabled: [{\n            type: Input,\n            args: ['mdeFocusTrapEnabled']\n        }], focusTrapAutoCaptureEnabled: [{\n            type: Input,\n            args: ['mdeFocusTrapAutoCaptureEnabled']\n        }], panelClass: [{\n            type: Input,\n            args: ['class']\n        }], classList: [{\n            type: Input\n        }], close: [{\n            type: Output\n        }], templateRef: [{\n            type: ViewChild,\n            args: [TemplateRef]\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(MdePopover, { className: \"MdePopover\", filePath: \"lib/popover/popover.ts\", lineNumber: 38 }); })();","originalLength":46985,"removedExports":[],"renderedExports":["MdePopover"],"renderedLength":18132},"D:/Blink/app-test-popover/popover/dist/material-extended/mde/esm2022/lib/popover/popover-trigger.mjs":{"code":"/**\n * This directive is intended to be used in conjunction with an mde-popover tag. It is\n * responsible for toggling the display of the provided popover instance.\n */\nclass MdePopoverTrigger {\n    constructor(_overlay, _elementRef, _viewContainerRef, _dir, _changeDetectorRef) {\n        this._overlay = _overlay;\n        this._elementRef = _elementRef;\n        this._viewContainerRef = _viewContainerRef;\n        this._dir = _dir;\n        this._changeDetectorRef = _changeDetectorRef;\n        this.ariaHaspopup = true;\n        this.popoverOpened = new Subject();\n        this.popoverClosed = new Subject();\n        this._overlayRef = null;\n        this._popoverOpen = false;\n        this._halt = false;\n        // tracking input type is necessary so it's possible to only auto-focus\n        // the first item of the list when the popover is opened via the keyboard\n        this._openedByMouse = false;\n        this._onDestroy = new Subject();\n        /** Popover backdrop close on click */\n        this.backdropCloseOnClick = true;\n        /** Event emitted when the associated popover is opened. */\n        this.opened = new EventEmitter();\n        /** Event emitted when the associated popover is closed. */\n        this.closed = new EventEmitter();\n    }\n    ngAfterViewInit() {\n        this._checkPopover();\n        this._setCurrentConfig();\n        this.popover.close.subscribe(() => this.closePopover());\n    }\n    ngOnDestroy() {\n        this.destroyPopover();\n    }\n    _setCurrentConfig() {\n        if (this.positionX === 'before' || this.positionX === 'after') {\n            this.popover.positionX = this.positionX;\n        }\n        if (this.positionY === 'above' || this.positionY === 'below') {\n            this.popover.positionY = this.positionY;\n        }\n        if (this.triggerEvent) {\n            this.popover.triggerEvent = this.triggerEvent;\n        }\n        if (this.enterDelay) {\n            this.popover.enterDelay = this.enterDelay;\n        }\n        if (this.leaveDelay) {\n            this.popover.leaveDelay = this.leaveDelay;\n        }\n        if (this.overlapTrigger === true || this.overlapTrigger === false) {\n            this.popover.overlapTrigger = this.overlapTrigger;\n        }\n        if (this.targetOffsetX) {\n            this.popover.targetOffsetX = this.targetOffsetX;\n        }\n        if (this.targetOffsetY) {\n            this.popover.targetOffsetY = this.targetOffsetY;\n        }\n        if (this.arrowOffsetX) {\n            this.popover.arrowOffsetX = this.arrowOffsetX;\n        }\n        if (this.arrowWidth) {\n            this.popover.arrowWidth = this.arrowWidth;\n        }\n        if (this.arrowColor) {\n            this.popover.arrowColor = this.arrowColor;\n        }\n        if (this.closeOnClick === true || this.closeOnClick === false) {\n            this.popover.closeOnClick = this.closeOnClick;\n        }\n        this.popover.setCurrentStyles();\n    }\n    /** Whether the popover is open. */\n    get popoverOpen() { return this._popoverOpen; }\n    onClick(event) {\n        if (this.popover.triggerEvent === 'click') {\n            this.togglePopover();\n        }\n    }\n    onMouseEnter(event) {\n        this._halt = false;\n        if (this.popover.triggerEvent === 'hover') {\n            this._mouseoverTimer = setTimeout(() => {\n                this.openPopover();\n            }, this.popover.enterDelay);\n        }\n    }\n    onMouseLeave(event) {\n        if (this.popover.triggerEvent === 'hover') {\n            if (this._mouseoverTimer) {\n                clearTimeout(this._mouseoverTimer);\n                this._mouseoverTimer = null;\n            }\n            if (this._popoverOpen) {\n                setTimeout(() => {\n                    if (!this.popover.closeDisabled) {\n                        this.closePopover();\n                    }\n                }, this.popover.leaveDelay);\n            }\n            else {\n                this._halt = true;\n            }\n        }\n    }\n    /** Toggles the popover between the open and closed states. */\n    togglePopover() {\n        return this._popoverOpen ? this.closePopover() : this.openPopover();\n    }\n    /** Opens the popover. */\n    openPopover() {\n        if (!this._popoverOpen && !this._halt) {\n            this._createOverlay().attach(this._portal);\n            this._subscribeToBackdrop();\n            this._subscribeToDetachments();\n            this._initPopover();\n        }\n    }\n    /** Closes the popover. */\n    closePopover() {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n            this._resetPopover();\n        }\n    }\n    /** Removes the popover from the DOM. */\n    destroyPopover() {\n        if (this._mouseoverTimer) {\n            clearTimeout(this._mouseoverTimer);\n            this._mouseoverTimer = null;\n        }\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n            this._overlayRef = null;\n            this._cleanUpSubscriptions();\n        }\n        this._onDestroy.next();\n        this._onDestroy.complete();\n    }\n    /** Focuses the popover trigger. */\n    focus() {\n        this._elementRef.nativeElement.focus();\n    }\n    /** The text direction of the containing app. */\n    get dir() {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    }\n    /**\n    * This method ensures that the popover closes when the overlay backdrop is clicked.\n    * We do not use first() here because doing so would not catch clicks from within\n    * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe\n    * explicitly when the popover is closed or destroyed.\n    */\n    _subscribeToBackdrop() {\n        if (this._overlayRef) {\n            /** Only subscribe to backdrop if trigger event is click */\n            if (this.triggerEvent === 'click' && this.backdropCloseOnClick === true) {\n                this._overlayRef.backdropClick()\n                    .pipe(takeUntil(this.popoverClosed), takeUntil(this._onDestroy))\n                    .subscribe(() => {\n                    this.popover._emitCloseEvent();\n                });\n            }\n        }\n    }\n    _subscribeToDetachments() {\n        if (this._overlayRef) {\n            this._overlayRef.detachments()\n                .pipe(takeUntil(this.popoverClosed), takeUntil(this._onDestroy))\n                .subscribe(() => {\n                this._setPopoverClosed();\n            });\n        }\n    }\n    /**\n    * This method sets the popover state to open and focuses the first item if\n    * the popover was opened via the keyboard.\n    */\n    _initPopover() {\n        this._setPopoverOpened();\n    }\n    /**\n    * This method resets the popover when it's closed, most importantly restoring\n    * focus to the popover trigger if the popover was opened via the keyboard.\n    */\n    _resetPopover() {\n        this._setPopoverClosed();\n        // Focus only needs to be reset to the host element if the popover was opened\n        // by the keyboard and manually shifted to the first popover item.\n        if (!this._openedByMouse) {\n            this.focus();\n        }\n        this._openedByMouse = false;\n    }\n    /** set state rather than toggle to support triggers sharing a popover */\n    _setPopoverOpened() {\n        if (!this._popoverOpen) {\n            this._popoverOpen = true;\n            this.popoverOpened.next();\n            this.opened.emit();\n        }\n    }\n    /** set state rather than toggle to support triggers sharing a popover */\n    _setPopoverClosed() {\n        if (this._popoverOpen) {\n            this._popoverOpen = false;\n            this.popoverClosed.next();\n            this.closed.emit();\n        }\n    }\n    /**\n    *  This method checks that a valid instance of MdPopover has been passed into\n    *  mdPopoverTriggerFor. If not, an exception is thrown.\n    */\n    _checkPopover() {\n        if (!this.popover) {\n            throwMdePopoverMissingError();\n        }\n    }\n    /**\n    *  This method creates the overlay from the provided popover's template and saves its\n    *  OverlayRef so that it can be attached to the DOM when openPopover is called.\n    */\n    _createOverlay() {\n        if (!this._overlayRef) {\n            this._portal = new TemplatePortal(this.popover.templateRef, this._viewContainerRef);\n            const config = this._getOverlayConfig();\n            this._subscribeToPositions(config.positionStrategy);\n            this._overlayRef = this._overlay.create(config);\n        }\n        return this._overlayRef;\n    }\n    /**\n    * This method builds the configuration object needed to create the overlay, the OverlayConfig.\n    * @returns OverlayConfig\n    */\n    _getOverlayConfig() {\n        const overlayState = new OverlayConfig();\n        overlayState.positionStrategy = this._getPosition();\n        /** Display overlay backdrop if trigger event is click */\n        if (this.triggerEvent === 'click') {\n            overlayState.hasBackdrop = true;\n            overlayState.backdropClass = 'cdk-overlay-transparent-backdrop';\n        }\n        overlayState.direction = this.dir;\n        overlayState.scrollStrategy = this._getOverlayScrollStrategy(this.popover.scrollStrategy);\n        return overlayState;\n    }\n    /**\n     * This method returns the scroll strategy used by the cdk/overlay.\n     */\n    _getOverlayScrollStrategy(strategy) {\n        switch (strategy) {\n            case 'noop':\n                return this._overlay.scrollStrategies.noop();\n            case 'close':\n                return this._overlay.scrollStrategies.close();\n            case 'block':\n                return this._overlay.scrollStrategies.block();\n            case 'reposition':\n            default:\n                return this._overlay.scrollStrategies.reposition();\n        }\n    }\n    /**\n    * Listens to changes in the position of the overlay and sets the correct classes\n    * on the popover based on the new position. This ensures the animation origin is always\n    * correct, even if a fallback position is used for the overlay.\n    */\n    _subscribeToPositions(position) {\n        this._positionSubscription = position.positionChanges.subscribe(change => {\n            const posisionX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\n            let posisionY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';\n            if (!this.popover.overlapTrigger) {\n                posisionY = posisionY === 'below' ? 'above' : 'below';\n            }\n            // required for ChangeDetectionStrategy.OnPush\n            this._changeDetectorRef.markForCheck();\n            this.popover.zone.run(() => {\n                this.popover.positionX = posisionX;\n                this.popover.positionY = posisionY;\n                this.popover.setCurrentStyles();\n                this.popover.setPositionClasses(posisionX, posisionY);\n            });\n        });\n    }\n    /**\n    * This method builds the position strategy for the overlay, so the popover is properly connected\n    * to the trigger.\n    * @returns ConnectedPositionStrategy\n    */\n    _getPosition() {\n        const [originX, originFallbackX] = this.popover.positionX === 'before' ? ['end', 'start'] : ['start', 'end'];\n        const [overlayY, overlayFallbackY] = this.popover.positionY === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];\n        // let originY = overlayY;\n        // let fallbackOriginY = overlayFallbackY;\n        let originY = overlayY;\n        let originFallbackY = overlayFallbackY;\n        const overlayX = originX;\n        const overlayFallbackX = originFallbackX;\n        // let [originY, originFallbackY] = [overlayY, overlayFallbackY];\n        // let [overlayX, overlayFallbackX] = [originX, originFallbackX];\n        /** Reverse overlayY and fallbackOverlayY when overlapTrigger is false */\n        if (!this.popover.overlapTrigger) {\n            originY = overlayY === 'top' ? 'bottom' : 'top';\n            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\n        }\n        let offsetX = 0;\n        let offsetY = 0;\n        if (this.popover.targetOffsetX && !isNaN(Number(this.popover.targetOffsetX))) {\n            offsetX = Number(this.popover.targetOffsetX);\n            // offsetX = -16;\n        }\n        if (this.popover.targetOffsetY && !isNaN(Number(this.popover.targetOffsetY))) {\n            offsetY = Number(this.popover.targetOffsetY);\n            // offsetY = -10;\n        }\n        /**\n         * For overriding position element, when mdePopoverTargetAt has a valid element reference.\n         * Useful for sticking popover to parent element and offsetting arrow to trigger element.\n         * If undefined defaults to the trigger element reference.\n         */\n        let element = this._elementRef;\n        if (typeof this.targetElement !== 'undefined') {\n            this.popover.containerPositioning = true;\n            element = this.targetElement._elementRef;\n        }\n        return this._overlay.position()\n            .flexibleConnectedTo(element)\n            .withLockedPosition(true)\n            .withPositions([\n            {\n                originX,\n                originY,\n                overlayX,\n                overlayY,\n                offsetY\n            },\n            {\n                originX: originFallbackX,\n                originY,\n                overlayX: overlayFallbackX,\n                overlayY,\n                offsetY\n            },\n            {\n                originX,\n                originY: originFallbackY,\n                overlayX,\n                overlayY: overlayFallbackY,\n                offsetY: -offsetY\n            },\n            {\n                originX: originFallbackX,\n                originY: originFallbackY,\n                overlayX: overlayFallbackX,\n                overlayY: overlayFallbackY,\n                offsetY: -offsetY\n            }\n        ])\n            .withDefaultOffsetX(offsetX)\n            .withDefaultOffsetY(offsetY);\n    }\n    _cleanUpSubscriptions() {\n        if (this._backdropSubscription) {\n            this._backdropSubscription.unsubscribe();\n        }\n        if (this._positionSubscription) {\n            this._positionSubscription.unsubscribe();\n        }\n        if (this._detachmentsSubscription) {\n            this._detachmentsSubscription.unsubscribe();\n        }\n    }\n    _handleMousedown(event) {\n        if (event && !isFakeMousedownFromScreenReader(event)) {\n            this._openedByMouse = true;\n        }\n    }\n    static { this.ɵfac = function MdePopoverTrigger_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || MdePopoverTrigger)(i0.ɵɵdirectiveInject(i1$1.Overlay), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i2$1.Directionality, 8), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); }; }\n    static { this.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: MdePopoverTrigger, selectors: [[\"\", \"mdePopoverTriggerFor\", \"\"]], hostVars: 1, hostBindings: function MdePopoverTrigger_HostBindings(rf, ctx) { if (rf & 1) {\n            i0.ɵɵlistener(\"click\", function MdePopoverTrigger_click_HostBindingHandler($event) { return ctx.onClick($event); })(\"mouseenter\", function MdePopoverTrigger_mouseenter_HostBindingHandler($event) { return ctx.onMouseEnter($event); })(\"mouseleave\", function MdePopoverTrigger_mouseleave_HostBindingHandler($event) { return ctx.onMouseLeave($event); })(\"mousedown\", function MdePopoverTrigger_mousedown_HostBindingHandler($event) { return ctx._handleMousedown($event); });\n        } if (rf & 2) {\n            i0.ɵɵattribute(\"aria-haspopup\", ctx.ariaHaspopup);\n        } }, inputs: { popover: [0, \"mdePopoverTriggerFor\", \"popover\"], targetElement: [0, \"mdePopoverTargetAt\", \"targetElement\"], positionX: [0, \"mdePopoverPositionX\", \"positionX\"], positionY: [0, \"mdePopoverPositionY\", \"positionY\"], triggerEvent: [0, \"mdePopoverTriggerOn\", \"triggerEvent\"], enterDelay: [0, \"mdePopoverEnterDelay\", \"enterDelay\"], leaveDelay: [0, \"mdePopoverLeaveDelay\", \"leaveDelay\"], overlapTrigger: [0, \"mdePopoverOverlapTrigger\", \"overlapTrigger\"], targetOffsetX: [0, \"mdePopoverOffsetX\", \"targetOffsetX\"], targetOffsetY: [0, \"mdePopoverOffsetY\", \"targetOffsetY\"], arrowOffsetX: [0, \"mdePopoverArrowOffsetX\", \"arrowOffsetX\"], arrowWidth: [0, \"mdePopoverArrowWidth\", \"arrowWidth\"], arrowColor: [0, \"mdePopoverArrowColor\", \"arrowColor\"], closeOnClick: [0, \"mdePopoverCloseOnClick\", \"closeOnClick\"], backdropCloseOnClick: [0, \"mdePopoverBackdropCloseOnClick\", \"backdropCloseOnClick\"] }, outputs: { opened: \"opened\", closed: \"closed\" }, exportAs: [\"mdePopoverTrigger\"], standalone: false }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MdePopoverTrigger, [{\n        type: Directive,\n        args: [{\n                selector: '[mdePopoverTriggerFor]',\n                exportAs: 'mdePopoverTrigger',\n                standalone: false\n            }]\n    }], () => [{ type: i1$1.Overlay }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2$1.Directionality, decorators: [{\n                type: Optional\n            }] }, { type: i0.ChangeDetectorRef }], { ariaHaspopup: [{\n            type: HostBinding,\n            args: ['attr.aria-haspopup']\n        }], popover: [{\n            type: Input,\n            args: ['mdePopoverTriggerFor']\n        }], targetElement: [{\n            type: Input,\n            args: ['mdePopoverTargetAt']\n        }], positionX: [{\n            type: Input,\n            args: ['mdePopoverPositionX']\n        }], positionY: [{\n            type: Input,\n            args: ['mdePopoverPositionY']\n        }], triggerEvent: [{\n            type: Input,\n            args: ['mdePopoverTriggerOn']\n        }], enterDelay: [{\n            type: Input,\n            args: ['mdePopoverEnterDelay']\n        }], leaveDelay: [{\n            type: Input,\n            args: ['mdePopoverLeaveDelay']\n        }], overlapTrigger: [{\n            type: Input,\n            args: ['mdePopoverOverlapTrigger']\n        }], targetOffsetX: [{\n            type: Input,\n            args: ['mdePopoverOffsetX']\n        }], targetOffsetY: [{\n            type: Input,\n            args: ['mdePopoverOffsetY']\n        }], arrowOffsetX: [{\n            type: Input,\n            args: ['mdePopoverArrowOffsetX']\n        }], arrowWidth: [{\n            type: Input,\n            args: ['mdePopoverArrowWidth']\n        }], arrowColor: [{\n            type: Input,\n            args: ['mdePopoverArrowColor']\n        }], closeOnClick: [{\n            type: Input,\n            args: ['mdePopoverCloseOnClick']\n        }], backdropCloseOnClick: [{\n            type: Input,\n            args: ['mdePopoverBackdropCloseOnClick']\n        }], opened: [{\n            type: Output\n        }], closed: [{\n            type: Output\n        }], onClick: [{\n            type: HostListener,\n            args: ['click', ['$event']]\n        }], onMouseEnter: [{\n            type: HostListener,\n            args: ['mouseenter', ['$event']]\n        }], onMouseLeave: [{\n            type: HostListener,\n            args: ['mouseleave', ['$event']]\n        }], _handleMousedown: [{\n            type: HostListener,\n            args: ['mousedown', ['$event']]\n        }] }); })();","originalLength":61740,"removedExports":[],"renderedExports":["MdePopoverTrigger"],"renderedLength":19161},"D:/Blink/app-test-popover/popover/dist/material-extended/mde/esm2022/lib/popover/popover-target.mjs":{"code":"class MdePopoverTarget {\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    static { this.ɵfac = function MdePopoverTarget_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || MdePopoverTarget)(i0.ɵɵdirectiveInject(i0.ElementRef)); }; }\n    static { this.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: MdePopoverTarget, selectors: [[\"mde-popover-target\"], [\"\", \"mdePopoverTarget\", \"\"]], exportAs: [\"mdePopoverTarget\"], standalone: false }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MdePopoverTarget, [{\n        type: Directive,\n        args: [{\n                selector: 'mde-popover-target, [mdePopoverTarget]',\n                exportAs: 'mdePopoverTarget',\n                standalone: false\n            }]\n    }], () => [{ type: i0.ElementRef }], null); })();","originalLength":2053,"removedExports":[],"renderedExports":["MdePopoverTarget"],"renderedLength":847},"D:/Blink/app-test-popover/popover/dist/material-extended/mde/esm2022/lib/popover/popover-module.mjs":{"code":"class MdePopoverModule {\n    static { this.ɵfac = function MdePopoverModule_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || MdePopoverModule)(); }; }\n    static { this.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: MdePopoverModule }); }\n    static { this.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [OverlayModule,\n            CommonModule,\n            A11yModule] }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MdePopoverModule, [{\n        type: NgModule,\n        args: [{\n                imports: [\n                    OverlayModule,\n                    CommonModule,\n                    A11yModule\n                ],\n                exports: [MdePopover, MdePopoverTrigger, MdePopoverTarget],\n                declarations: [MdePopover, MdePopoverTrigger, MdePopoverTarget],\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(MdePopoverModule, { declarations: [MdePopover, MdePopoverTrigger, MdePopoverTarget], imports: [OverlayModule,\n        CommonModule,\n        A11yModule], exports: [MdePopover, MdePopoverTrigger, MdePopoverTarget] }); })();","originalLength":3698,"removedExports":[],"renderedExports":["MdePopoverModule"],"renderedLength":1195},"D:/Blink/app-test-popover/popover/dist/material-extended/mde/esm2022/lib/popover/popover-interfaces.mjs":{"code":"","originalLength":2321,"removedExports":[],"renderedExports":[],"renderedLength":0},"D:/Blink/app-test-popover/popover/dist/material-extended/mde/esm2022/public_api.mjs":{"code":"/*\n * Public API Surface of mde\n */","originalLength":1252,"removedExports":[],"renderedExports":[],"renderedLength":35},"D:\\Blink\\app-test-popover\\popover\\dist\\material-extended\\mde\\esm2022\\material-extended-mde.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":544,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, TemplateRef, ViewEncapsulation, ChangeDetectionStrategy, Component, ViewChild, Output, Input, HostBinding, Directive, Optional, HostListener, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i1$1 from '@angular/cdk/overlay';\nimport { OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE } from '@angular/cdk/keycodes';\nimport { trigger, state, transition, style, animate } from '@angular/animations';\nimport * as i2 from '@angular/cdk/a11y';\nimport { isFakeMousedownFromScreenReader, A11yModule } from '@angular/cdk/a11y';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport * as i2$1 from '@angular/cdk/bidi';\n\n/**\n * Throws an exception for the case when popover trigger doesn't have a valid mde-popover instance\n */\nfunction throwMdePopoverMissingError() {\n    throw Error(`mde-popover-trigger: must pass in an mde-popover instance.\r\n\r\n    Example:\r\n      <mde-popover #popover=\"mdePopover\"></mde-popover>\r\n      <button [mdePopoverTriggerFor]=\"popover\"></button>`);\n}\n/**\n * Throws an exception for the case when popover's mdePopoverPositionX value isn't valid.\n * In other words, it doesn't match 'before' or 'after'.\n */\nfunction throwMdePopoverInvalidPositionX() {\n    throw Error(`mdePopoverPositionX value must be either 'before' or after'.\r\n      Example: <mde-popover mdePopoverPositionX=\"before\" #popover=\"mdePopover\"></mde-popover>`);\n}\n/**\n * Throws an exception for the case when popover's mdePopoverPositionY value isn't valid.\n * In other words, it doesn't match 'above' or 'below'.\n */\nfunction throwMdePopoverInvalidPositionY() {\n    throw Error(`mdePopoverPositionY value must be either 'above' or below'.\r\n      Example: <mde-popover mdePopoverPositionY=\"above\" #popover=\"mdePopover\"></mde-popover>`);\n}\n\n/**\n * Below are all the animations for the md-popover component.\n * Animation duration and timing values are based on AngularJS Material.\n */\n/**\n * This animation controls the popover panel's entry and exit from the page.\n *\n * When the popover panel is added to the DOM, it scales in and fades in its border.\n *\n * When the popover panel is removed from the DOM, it simply fades out after a brief\n * delay to display the ripple.\n */\nconst transformPopover = trigger('transformPopover', [\n    state('enter', style({\n        opacity: 1,\n        transform: `scale(1)`\n    })),\n    transition('void => *', [\n        style({\n            opacity: 0,\n            transform: `scale(0)`\n        }),\n        animate(`200ms cubic-bezier(0.25, 0.8, 0.25, 1)`)\n    ]),\n    transition('* => void', [\n        animate('50ms 100ms linear', style({ opacity: 0 }))\n    ])\n]);\n\nconst _c0 = [\"*\"];\nfunction MdePopover_ng_template_0_div_1_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 3);\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngStyle\", ctx_r1.popoverArrowStyles);\n} }\nfunction MdePopover_ng_template_0_Template(rf, ctx) { if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 0);\n    i0.ɵɵlistener(\"keydown\", function MdePopover_ng_template_0_Template_div_keydown_0_listener($event) { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1._handleKeydown($event)); })(\"click\", function MdePopover_ng_template_0_Template_div_click_0_listener() { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.onClick()); })(\"mouseover\", function MdePopover_ng_template_0_Template_div_mouseover_0_listener() { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.onMouseOver()); })(\"mouseleave\", function MdePopover_ng_template_0_Template_div_mouseleave_0_listener() { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.onMouseLeave()); });\n    i0.ɵɵtemplate(1, MdePopover_ng_template_0_div_1_Template, 1, 1, \"div\", 1);\n    i0.ɵɵelementStart(2, \"div\", 2);\n    i0.ɵɵprojection(3);\n    i0.ɵɵelementEnd()();\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"mde-popover-overlap\", ctx_r1.overlapTrigger);\n    i0.ɵɵproperty(\"ngClass\", ctx_r1._classList)(\"ngStyle\", ctx_r1.popoverPanelStyles)(\"@.disabled\", ctx_r1.disableAnimation)(\"@transformPopover\", \"enter\");\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngIf\", !ctx_r1.overlapTrigger);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngStyle\", ctx_r1.popoverContentStyles)(\"cdkTrapFocus\", ctx_r1.focusTrapEnabled)(\"cdkTrapFocusAutoCapture\", ctx_r1.focusTrapAutoCaptureEnabled);\n} }\nclass MdePopover {\n    /** Position of the popover in the X axis. */\n    get positionX() { return this._positionX; }\n    set positionX(value) {\n        if (value !== 'before' && value !== 'after') {\n            throwMdePopoverInvalidPositionX();\n        }\n        this._positionX = value;\n        this.setPositionClasses();\n    }\n    /** Position of the popover in the Y axis. */\n    get positionY() { return this._positionY; }\n    set positionY(value) {\n        if (value !== 'above' && value !== 'below') {\n            throwMdePopoverInvalidPositionY();\n        }\n        this._positionY = value;\n        this.setPositionClasses();\n    }\n    /** Popover trigger event */\n    get triggerEvent() { return this._triggerEvent; }\n    set triggerEvent(value) { this._triggerEvent = value; }\n    /** Popover scroll strategy */\n    get scrollStrategy() { return this._scrollStrategy; }\n    set scrollStrategy(value) { this._scrollStrategy = value; }\n    /** Popover enter delay */\n    get enterDelay() { return this._enterDelay; }\n    set enterDelay(value) { this._enterDelay = value; }\n    /** Popover leave delay */\n    get leaveDelay() { return this._leaveDelay; }\n    set leaveDelay(value) { this._leaveDelay = value; }\n    /** Popover overlap trigger */\n    get overlapTrigger() { return this._overlapTrigger; }\n    set overlapTrigger(value) { this._overlapTrigger = value; }\n    /** Popover target offset x */\n    get targetOffsetX() { return this._targetOffsetX; }\n    set targetOffsetX(value) { this._targetOffsetX = value; }\n    /** Popover target offset y */\n    get targetOffsetY() { return this._targetOffsetY; }\n    set targetOffsetY(value) { this._targetOffsetY = value; }\n    /** Popover arrow offset x */\n    get arrowOffsetX() { return this._arrowOffsetX; }\n    set arrowOffsetX(value) { this._arrowOffsetX = value; }\n    /** Popover arrow width */\n    get arrowWidth() { return this._arrowWidth; }\n    set arrowWidth(value) { this._arrowWidth = value; }\n    /** Popover arrow color */\n    get arrowColor() { return this._arrowColor; }\n    set arrowColor(value) { this._arrowColor = value; }\n    /**\n     * Popover container close on click\n     * default: true\n     */\n    get closeOnClick() { return this._closeOnClick; }\n    set closeOnClick(value) { this._closeOnClick = coerceBooleanProperty(value); }\n    /**\n     * Disable animations of popover and all child elements\n     * default: false\n     */\n    get disableAnimation() { return this._disableAnimation; }\n    set disableAnimation(value) { this._disableAnimation = coerceBooleanProperty(value); }\n    /**\n     * Popover focus trap using cdkTrapFocus\n     * default: true\n     */\n    get focusTrapEnabled() { return this._focusTrapEnabled; }\n    set focusTrapEnabled(value) { this._focusTrapEnabled = coerceBooleanProperty(value); }\n    /**\n     * Popover focus trap auto capture using cdkTrapFocusAutoCapture\n     * default: true\n     */\n    get focusTrapAutoCaptureEnabled() { return this._focusTrapAutoCaptureEnabled; }\n    set focusTrapAutoCaptureEnabled(value) { this._focusTrapAutoCaptureEnabled = coerceBooleanProperty(value); }\n    /**\n     * This method takes classes set on the host md-popover element and applies them on the\n     * popover template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing popover from outside the component.\n     * @param classes list of class names\n     */\n    set panelClass(classes) {\n        if (classes && classes.length) {\n            this._classList = classes.split(' ').reduce((obj, className) => {\n                obj[className] = true;\n                return obj;\n            }, {});\n            this._elementRef.nativeElement.className = '';\n            this.setPositionClasses();\n        }\n    }\n    /**\n     * This method takes classes set on the host md-popover element and applies them on the\n     * popover template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing popover from outside the component.\n     * @deprecated Use `panelClass` instead.\n     */\n    get classList() { return this.panelClass; }\n    set classList(classes) { this.panelClass = classes; }\n    constructor(_elementRef, zone) {\n        this._elementRef = _elementRef;\n        this.zone = zone;\n        this.role = 'dialog';\n        /** Settings for popover, view setters and getters for more detail */\n        this._positionX = 'after';\n        this._positionY = 'below';\n        this._triggerEvent = 'hover';\n        this._scrollStrategy = 'reposition';\n        this._enterDelay = 200;\n        this._leaveDelay = 200;\n        this._overlapTrigger = true;\n        this._disableAnimation = false;\n        this._targetOffsetX = 0;\n        this._targetOffsetY = 0;\n        this._arrowOffsetX = 20;\n        this._arrowWidth = 8;\n        this._arrowColor = 'rgba(0, 0, 0, 0.12)';\n        this._closeOnClick = true;\n        this._focusTrapEnabled = true;\n        this._focusTrapAutoCaptureEnabled = true;\n        /** Config object to be passed into the popover's ngClass */\n        this._classList = {};\n        // TODO: Write comment description\n        /** */\n        this.containerPositioning = false;\n        /** Closing disabled on popover */\n        this.closeDisabled = false;\n        /** Emits the current animation state whenever it changes. */\n        this._onAnimationStateChange = new EventEmitter();\n        /** Event emitted when the popover is closed. */\n        this.close = new EventEmitter();\n        this.setPositionClasses();\n    }\n    ngOnDestroy() {\n        this._emitCloseEvent();\n        this.close.complete();\n    }\n    /** Handle a keyboard event from the popover, delegating to the appropriate action. */\n    _handleKeydown(event) {\n        switch (event.keyCode) {\n            case ESCAPE:\n                this._emitCloseEvent();\n                return;\n        }\n    }\n    /**\n     * This emits a close event to which the trigger is subscribed. When emitted, the\n     * trigger will close the popover.\n     */\n    _emitCloseEvent() {\n        this.close.emit();\n    }\n    /** Close popover on click if closeOnClick is true */\n    onClick() {\n        if (this.closeOnClick) {\n            this._emitCloseEvent();\n        }\n    }\n    /**\n     * TODO: Refactor when @angular/cdk includes feature I mentioned on github see link below.\n     * https://github.com/angular/material2/pull/5493#issuecomment-313085323\n     */\n    /** Disables close of popover when leaving trigger element and mouse over the popover */\n    onMouseOver() {\n        if (this.triggerEvent === 'hover') {\n            this.closeDisabled = true;\n        }\n    }\n    /** Enables close of popover when mouse leaving popover element */\n    onMouseLeave() {\n        if (this.triggerEvent === 'hover') {\n            this.closeDisabled = false;\n            this._emitCloseEvent();\n        }\n    }\n    // TODO: Refactor how styles are set and updated on the component, use best practices.\n    // TODO: If arrow left and right positioning is requested, see if flex direction can be used to work with order.\n    /** Sets the current styles for the popover to allow for dynamically changing settings */\n    setCurrentStyles() {\n        // TODO: See if arrow position can be calculated automatically and allow override.\n        // TODO: See if flex order is a better alternative to position arrow top or bottom.\n        this.popoverArrowStyles = {\n            'right': this.positionX === 'before' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',\n            'left': this.positionX === 'after' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',\n            'border-top': this.positionY === 'below' ?\n                this.arrowWidth + 'px solid ' + this.arrowColor : '0px solid transparent',\n            'border-right': 'undefined' === undefined ?\n                this.arrowWidth + 'px solid ' + this.arrowColor :\n                this.arrowWidth + 'px solid transparent',\n            'border-bottom': this.positionY === 'above' ?\n                this.arrowWidth + 'px solid ' + this.arrowColor :\n                this.arrowWidth + 'px solid transparent',\n            'border-left': 'undefined' === undefined ?\n                this.arrowWidth + 'px solid ' + this.arrowColor :\n                this.arrowWidth + 'px solid transparent',\n        };\n        // TODO: Remove if flex order is added.\n        this.popoverContentStyles = {\n            'padding-top': this.overlapTrigger === true ? '0px' : this.arrowWidth + 'px',\n            'padding-bottom': this.overlapTrigger === true ? '0px' : (this.arrowWidth) + 'px',\n            'margin-top': this.overlapTrigger === false && this.positionY === 'below' && this.containerPositioning === false ?\n                -(this.arrowWidth * 2) + 'px' : '0px'\n        };\n    }\n    /**\n     * It's necessary to set position-based classes to ensure the popover panel animation\n     * folds out from the correct direction.\n     */\n    setPositionClasses(posX = this.positionX, posY = this.positionY) {\n        this._classList['mde-popover-before'] = posX === 'before';\n        this._classList['mde-popover-after'] = posX === 'after';\n        this._classList['mde-popover-above'] = posY === 'above';\n        this._classList['mde-popover-below'] = posY === 'below';\n    }\n    static { this.ɵfac = function MdePopover_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || MdePopover)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone)); }; }\n    static { this.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: MdePopover, selectors: [[\"mde-popover\"]], viewQuery: function MdePopover_Query(rf, ctx) { if (rf & 1) {\n            i0.ɵɵviewQuery(TemplateRef, 5);\n        } if (rf & 2) {\n            let _t;\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);\n        } }, hostVars: 1, hostBindings: function MdePopover_HostBindings(rf, ctx) { if (rf & 2) {\n            i0.ɵɵattribute(\"role\", ctx.role);\n        } }, inputs: { positionX: [0, \"mdePopoverPositionX\", \"positionX\"], positionY: [0, \"mdePopoverPositionY\", \"positionY\"], triggerEvent: [0, \"mdePopoverTriggerOn\", \"triggerEvent\"], scrollStrategy: [0, \"mdePopoverScrollStrategy\", \"scrollStrategy\"], enterDelay: [0, \"mdePopoverEnterDelay\", \"enterDelay\"], leaveDelay: [0, \"mdePopoverLeaveDelay\", \"leaveDelay\"], overlapTrigger: [0, \"mdePopoverOverlapTrigger\", \"overlapTrigger\"], targetOffsetX: [0, \"mdePopoverOffsetX\", \"targetOffsetX\"], targetOffsetY: [0, \"mdePopoverOffsetY\", \"targetOffsetY\"], arrowOffsetX: [0, \"mdePopoverArrowOffsetX\", \"arrowOffsetX\"], arrowWidth: [0, \"mdePopoverArrowWidth\", \"arrowWidth\"], arrowColor: [0, \"mdePopoverArrowColor\", \"arrowColor\"], closeOnClick: [0, \"mdePopoverCloseOnClick\", \"closeOnClick\"], disableAnimation: [0, \"mdePopoverDisableAnimation\", \"disableAnimation\"], focusTrapEnabled: [0, \"mdeFocusTrapEnabled\", \"focusTrapEnabled\"], focusTrapAutoCaptureEnabled: [0, \"mdeFocusTrapAutoCaptureEnabled\", \"focusTrapAutoCaptureEnabled\"], panelClass: [0, \"class\", \"panelClass\"], classList: \"classList\" }, outputs: { close: \"close\" }, exportAs: [\"mdePopover\"], standalone: false, ngContentSelectors: _c0, decls: 1, vars: 0, consts: [[\"role\", \"dialog\", 1, \"mde-popover-panel\", 3, \"keydown\", \"click\", \"mouseover\", \"mouseleave\", \"ngClass\", \"ngStyle\"], [\"class\", \"mde-popover-direction-arrow\", 3, \"ngStyle\", 4, \"ngIf\"], [1, \"mde-popover-content\", 3, \"ngStyle\", \"cdkTrapFocus\", \"cdkTrapFocusAutoCapture\"], [1, \"mde-popover-direction-arrow\", 3, \"ngStyle\"]], template: function MdePopover_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵprojectionDef();\n            i0.ɵɵtemplate(0, MdePopover_ng_template_0_Template, 4, 10, \"ng-template\");\n        } }, dependencies: [i1.NgClass, i1.NgIf, i1.NgStyle, i2.CdkTrapFocus], styles: [\".mde-popover-panel{display:flex;flex-direction:column;max-height:calc(100vh + 48px)}.mde-popover-ripple{position:absolute;inset:0}.mde-popover-below .mde-popover-direction-arrow{position:absolute;bottom:0;width:0;height:0;border-bottom-width:0!important;z-index:99999}.mde-popover-above .mde-popover-direction-arrow{position:absolute;top:0;width:0;height:0;border-top-width:0!important;z-index:99999}.mde-popover-after .mde-popover-direction-arrow{left:20px}.mde-popover-before .mde-popover-direction-arrow{right:20px}\\n\"], encapsulation: 2, data: { animation: [\n                transformPopover\n            ] }, changeDetection: 0 }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MdePopover, [{\n        type: Component,\n        args: [{ selector: 'mde-popover', changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, animations: [\n                    transformPopover\n                ], exportAs: 'mdePopover', standalone: false, template: \"<ng-template>\\r\\n  <div class=\\\"mde-popover-panel\\\" role=\\\"dialog\\\" [class.mde-popover-overlap]=\\\"overlapTrigger\\\"\\r\\n       [ngClass]=\\\"_classList\\\" [ngStyle]=\\\"popoverPanelStyles\\\" (keydown)=\\\"_handleKeydown($event)\\\"\\r\\n       (click)=\\\"onClick()\\\" (mouseover)=\\\"onMouseOver()\\\" (mouseleave)=\\\"onMouseLeave()\\\" [@.disabled]=\\\"disableAnimation\\\"\\r\\n       [@transformPopover]=\\\"'enter'\\\">\\r\\n    <div class=\\\"mde-popover-direction-arrow\\\" [ngStyle]=\\\"popoverArrowStyles\\\" *ngIf=\\\"!overlapTrigger\\\"></div>\\r\\n    <div class=\\\"mde-popover-content\\\" [ngStyle]=\\\"popoverContentStyles\\\" [cdkTrapFocus]=\\\"focusTrapEnabled\\\" [cdkTrapFocusAutoCapture]=\\\"focusTrapAutoCaptureEnabled\\\">\\r\\n      <ng-content></ng-content>\\r\\n    </div>\\r\\n  </div>\\r\\n</ng-template>\\r\\n\", styles: [\".mde-popover-panel{display:flex;flex-direction:column;max-height:calc(100vh + 48px)}.mde-popover-ripple{position:absolute;inset:0}.mde-popover-below .mde-popover-direction-arrow{position:absolute;bottom:0;width:0;height:0;border-bottom-width:0!important;z-index:99999}.mde-popover-above .mde-popover-direction-arrow{position:absolute;top:0;width:0;height:0;border-top-width:0!important;z-index:99999}.mde-popover-after .mde-popover-direction-arrow{left:20px}.mde-popover-before .mde-popover-direction-arrow{right:20px}\\n\"] }]\n    }], () => [{ type: i0.ElementRef }, { type: i0.NgZone }], { role: [{\n            type: HostBinding,\n            args: ['attr.role']\n        }], positionX: [{\n            type: Input,\n            args: ['mdePopoverPositionX']\n        }], positionY: [{\n            type: Input,\n            args: ['mdePopoverPositionY']\n        }], triggerEvent: [{\n            type: Input,\n            args: ['mdePopoverTriggerOn']\n        }], scrollStrategy: [{\n            type: Input,\n            args: ['mdePopoverScrollStrategy']\n        }], enterDelay: [{\n            type: Input,\n            args: ['mdePopoverEnterDelay']\n        }], leaveDelay: [{\n            type: Input,\n            args: ['mdePopoverLeaveDelay']\n        }], overlapTrigger: [{\n            type: Input,\n            args: ['mdePopoverOverlapTrigger']\n        }], targetOffsetX: [{\n            type: Input,\n            args: ['mdePopoverOffsetX']\n        }], targetOffsetY: [{\n            type: Input,\n            args: ['mdePopoverOffsetY']\n        }], arrowOffsetX: [{\n            type: Input,\n            args: ['mdePopoverArrowOffsetX']\n        }], arrowWidth: [{\n            type: Input,\n            args: ['mdePopoverArrowWidth']\n        }], arrowColor: [{\n            type: Input,\n            args: ['mdePopoverArrowColor']\n        }], closeOnClick: [{\n            type: Input,\n            args: ['mdePopoverCloseOnClick']\n        }], disableAnimation: [{\n            type: Input,\n            args: ['mdePopoverDisableAnimation']\n        }], focusTrapEnabled: [{\n            type: Input,\n            args: ['mdeFocusTrapEnabled']\n        }], focusTrapAutoCaptureEnabled: [{\n            type: Input,\n            args: ['mdeFocusTrapAutoCaptureEnabled']\n        }], panelClass: [{\n            type: Input,\n            args: ['class']\n        }], classList: [{\n            type: Input\n        }], close: [{\n            type: Output\n        }], templateRef: [{\n            type: ViewChild,\n            args: [TemplateRef]\n        }] }); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(MdePopover, { className: \"MdePopover\", filePath: \"lib/popover/popover.ts\", lineNumber: 38 }); })();\n\n/**\n * This directive is intended to be used in conjunction with an mde-popover tag. It is\n * responsible for toggling the display of the provided popover instance.\n */\nclass MdePopoverTrigger {\n    constructor(_overlay, _elementRef, _viewContainerRef, _dir, _changeDetectorRef) {\n        this._overlay = _overlay;\n        this._elementRef = _elementRef;\n        this._viewContainerRef = _viewContainerRef;\n        this._dir = _dir;\n        this._changeDetectorRef = _changeDetectorRef;\n        this.ariaHaspopup = true;\n        this.popoverOpened = new Subject();\n        this.popoverClosed = new Subject();\n        this._overlayRef = null;\n        this._popoverOpen = false;\n        this._halt = false;\n        // tracking input type is necessary so it's possible to only auto-focus\n        // the first item of the list when the popover is opened via the keyboard\n        this._openedByMouse = false;\n        this._onDestroy = new Subject();\n        /** Popover backdrop close on click */\n        this.backdropCloseOnClick = true;\n        /** Event emitted when the associated popover is opened. */\n        this.opened = new EventEmitter();\n        /** Event emitted when the associated popover is closed. */\n        this.closed = new EventEmitter();\n    }\n    ngAfterViewInit() {\n        this._checkPopover();\n        this._setCurrentConfig();\n        this.popover.close.subscribe(() => this.closePopover());\n    }\n    ngOnDestroy() {\n        this.destroyPopover();\n    }\n    _setCurrentConfig() {\n        if (this.positionX === 'before' || this.positionX === 'after') {\n            this.popover.positionX = this.positionX;\n        }\n        if (this.positionY === 'above' || this.positionY === 'below') {\n            this.popover.positionY = this.positionY;\n        }\n        if (this.triggerEvent) {\n            this.popover.triggerEvent = this.triggerEvent;\n        }\n        if (this.enterDelay) {\n            this.popover.enterDelay = this.enterDelay;\n        }\n        if (this.leaveDelay) {\n            this.popover.leaveDelay = this.leaveDelay;\n        }\n        if (this.overlapTrigger === true || this.overlapTrigger === false) {\n            this.popover.overlapTrigger = this.overlapTrigger;\n        }\n        if (this.targetOffsetX) {\n            this.popover.targetOffsetX = this.targetOffsetX;\n        }\n        if (this.targetOffsetY) {\n            this.popover.targetOffsetY = this.targetOffsetY;\n        }\n        if (this.arrowOffsetX) {\n            this.popover.arrowOffsetX = this.arrowOffsetX;\n        }\n        if (this.arrowWidth) {\n            this.popover.arrowWidth = this.arrowWidth;\n        }\n        if (this.arrowColor) {\n            this.popover.arrowColor = this.arrowColor;\n        }\n        if (this.closeOnClick === true || this.closeOnClick === false) {\n            this.popover.closeOnClick = this.closeOnClick;\n        }\n        this.popover.setCurrentStyles();\n    }\n    /** Whether the popover is open. */\n    get popoverOpen() { return this._popoverOpen; }\n    onClick(event) {\n        if (this.popover.triggerEvent === 'click') {\n            this.togglePopover();\n        }\n    }\n    onMouseEnter(event) {\n        this._halt = false;\n        if (this.popover.triggerEvent === 'hover') {\n            this._mouseoverTimer = setTimeout(() => {\n                this.openPopover();\n            }, this.popover.enterDelay);\n        }\n    }\n    onMouseLeave(event) {\n        if (this.popover.triggerEvent === 'hover') {\n            if (this._mouseoverTimer) {\n                clearTimeout(this._mouseoverTimer);\n                this._mouseoverTimer = null;\n            }\n            if (this._popoverOpen) {\n                setTimeout(() => {\n                    if (!this.popover.closeDisabled) {\n                        this.closePopover();\n                    }\n                }, this.popover.leaveDelay);\n            }\n            else {\n                this._halt = true;\n            }\n        }\n    }\n    /** Toggles the popover between the open and closed states. */\n    togglePopover() {\n        return this._popoverOpen ? this.closePopover() : this.openPopover();\n    }\n    /** Opens the popover. */\n    openPopover() {\n        if (!this._popoverOpen && !this._halt) {\n            this._createOverlay().attach(this._portal);\n            this._subscribeToBackdrop();\n            this._subscribeToDetachments();\n            this._initPopover();\n        }\n    }\n    /** Closes the popover. */\n    closePopover() {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n            this._resetPopover();\n        }\n    }\n    /** Removes the popover from the DOM. */\n    destroyPopover() {\n        if (this._mouseoverTimer) {\n            clearTimeout(this._mouseoverTimer);\n            this._mouseoverTimer = null;\n        }\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n            this._overlayRef = null;\n            this._cleanUpSubscriptions();\n        }\n        this._onDestroy.next();\n        this._onDestroy.complete();\n    }\n    /** Focuses the popover trigger. */\n    focus() {\n        this._elementRef.nativeElement.focus();\n    }\n    /** The text direction of the containing app. */\n    get dir() {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    }\n    /**\n    * This method ensures that the popover closes when the overlay backdrop is clicked.\n    * We do not use first() here because doing so would not catch clicks from within\n    * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe\n    * explicitly when the popover is closed or destroyed.\n    */\n    _subscribeToBackdrop() {\n        if (this._overlayRef) {\n            /** Only subscribe to backdrop if trigger event is click */\n            if (this.triggerEvent === 'click' && this.backdropCloseOnClick === true) {\n                this._overlayRef.backdropClick()\n                    .pipe(takeUntil(this.popoverClosed), takeUntil(this._onDestroy))\n                    .subscribe(() => {\n                    this.popover._emitCloseEvent();\n                });\n            }\n        }\n    }\n    _subscribeToDetachments() {\n        if (this._overlayRef) {\n            this._overlayRef.detachments()\n                .pipe(takeUntil(this.popoverClosed), takeUntil(this._onDestroy))\n                .subscribe(() => {\n                this._setPopoverClosed();\n            });\n        }\n    }\n    /**\n    * This method sets the popover state to open and focuses the first item if\n    * the popover was opened via the keyboard.\n    */\n    _initPopover() {\n        this._setPopoverOpened();\n    }\n    /**\n    * This method resets the popover when it's closed, most importantly restoring\n    * focus to the popover trigger if the popover was opened via the keyboard.\n    */\n    _resetPopover() {\n        this._setPopoverClosed();\n        // Focus only needs to be reset to the host element if the popover was opened\n        // by the keyboard and manually shifted to the first popover item.\n        if (!this._openedByMouse) {\n            this.focus();\n        }\n        this._openedByMouse = false;\n    }\n    /** set state rather than toggle to support triggers sharing a popover */\n    _setPopoverOpened() {\n        if (!this._popoverOpen) {\n            this._popoverOpen = true;\n            this.popoverOpened.next();\n            this.opened.emit();\n        }\n    }\n    /** set state rather than toggle to support triggers sharing a popover */\n    _setPopoverClosed() {\n        if (this._popoverOpen) {\n            this._popoverOpen = false;\n            this.popoverClosed.next();\n            this.closed.emit();\n        }\n    }\n    /**\n    *  This method checks that a valid instance of MdPopover has been passed into\n    *  mdPopoverTriggerFor. If not, an exception is thrown.\n    */\n    _checkPopover() {\n        if (!this.popover) {\n            throwMdePopoverMissingError();\n        }\n    }\n    /**\n    *  This method creates the overlay from the provided popover's template and saves its\n    *  OverlayRef so that it can be attached to the DOM when openPopover is called.\n    */\n    _createOverlay() {\n        if (!this._overlayRef) {\n            this._portal = new TemplatePortal(this.popover.templateRef, this._viewContainerRef);\n            const config = this._getOverlayConfig();\n            this._subscribeToPositions(config.positionStrategy);\n            this._overlayRef = this._overlay.create(config);\n        }\n        return this._overlayRef;\n    }\n    /**\n    * This method builds the configuration object needed to create the overlay, the OverlayConfig.\n    * @returns OverlayConfig\n    */\n    _getOverlayConfig() {\n        const overlayState = new OverlayConfig();\n        overlayState.positionStrategy = this._getPosition();\n        /** Display overlay backdrop if trigger event is click */\n        if (this.triggerEvent === 'click') {\n            overlayState.hasBackdrop = true;\n            overlayState.backdropClass = 'cdk-overlay-transparent-backdrop';\n        }\n        overlayState.direction = this.dir;\n        overlayState.scrollStrategy = this._getOverlayScrollStrategy(this.popover.scrollStrategy);\n        return overlayState;\n    }\n    /**\n     * This method returns the scroll strategy used by the cdk/overlay.\n     */\n    _getOverlayScrollStrategy(strategy) {\n        switch (strategy) {\n            case 'noop':\n                return this._overlay.scrollStrategies.noop();\n            case 'close':\n                return this._overlay.scrollStrategies.close();\n            case 'block':\n                return this._overlay.scrollStrategies.block();\n            case 'reposition':\n            default:\n                return this._overlay.scrollStrategies.reposition();\n        }\n    }\n    /**\n    * Listens to changes in the position of the overlay and sets the correct classes\n    * on the popover based on the new position. This ensures the animation origin is always\n    * correct, even if a fallback position is used for the overlay.\n    */\n    _subscribeToPositions(position) {\n        this._positionSubscription = position.positionChanges.subscribe(change => {\n            const posisionX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\n            let posisionY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';\n            if (!this.popover.overlapTrigger) {\n                posisionY = posisionY === 'below' ? 'above' : 'below';\n            }\n            // required for ChangeDetectionStrategy.OnPush\n            this._changeDetectorRef.markForCheck();\n            this.popover.zone.run(() => {\n                this.popover.positionX = posisionX;\n                this.popover.positionY = posisionY;\n                this.popover.setCurrentStyles();\n                this.popover.setPositionClasses(posisionX, posisionY);\n            });\n        });\n    }\n    /**\n    * This method builds the position strategy for the overlay, so the popover is properly connected\n    * to the trigger.\n    * @returns ConnectedPositionStrategy\n    */\n    _getPosition() {\n        const [originX, originFallbackX] = this.popover.positionX === 'before' ? ['end', 'start'] : ['start', 'end'];\n        const [overlayY, overlayFallbackY] = this.popover.positionY === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];\n        // let originY = overlayY;\n        // let fallbackOriginY = overlayFallbackY;\n        let originY = overlayY;\n        let originFallbackY = overlayFallbackY;\n        const overlayX = originX;\n        const overlayFallbackX = originFallbackX;\n        // let [originY, originFallbackY] = [overlayY, overlayFallbackY];\n        // let [overlayX, overlayFallbackX] = [originX, originFallbackX];\n        /** Reverse overlayY and fallbackOverlayY when overlapTrigger is false */\n        if (!this.popover.overlapTrigger) {\n            originY = overlayY === 'top' ? 'bottom' : 'top';\n            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\n        }\n        let offsetX = 0;\n        let offsetY = 0;\n        if (this.popover.targetOffsetX && !isNaN(Number(this.popover.targetOffsetX))) {\n            offsetX = Number(this.popover.targetOffsetX);\n            // offsetX = -16;\n        }\n        if (this.popover.targetOffsetY && !isNaN(Number(this.popover.targetOffsetY))) {\n            offsetY = Number(this.popover.targetOffsetY);\n            // offsetY = -10;\n        }\n        /**\n         * For overriding position element, when mdePopoverTargetAt has a valid element reference.\n         * Useful for sticking popover to parent element and offsetting arrow to trigger element.\n         * If undefined defaults to the trigger element reference.\n         */\n        let element = this._elementRef;\n        if (typeof this.targetElement !== 'undefined') {\n            this.popover.containerPositioning = true;\n            element = this.targetElement._elementRef;\n        }\n        return this._overlay.position()\n            .flexibleConnectedTo(element)\n            .withLockedPosition(true)\n            .withPositions([\n            {\n                originX,\n                originY,\n                overlayX,\n                overlayY,\n                offsetY\n            },\n            {\n                originX: originFallbackX,\n                originY,\n                overlayX: overlayFallbackX,\n                overlayY,\n                offsetY\n            },\n            {\n                originX,\n                originY: originFallbackY,\n                overlayX,\n                overlayY: overlayFallbackY,\n                offsetY: -offsetY\n            },\n            {\n                originX: originFallbackX,\n                originY: originFallbackY,\n                overlayX: overlayFallbackX,\n                overlayY: overlayFallbackY,\n                offsetY: -offsetY\n            }\n        ])\n            .withDefaultOffsetX(offsetX)\n            .withDefaultOffsetY(offsetY);\n    }\n    _cleanUpSubscriptions() {\n        if (this._backdropSubscription) {\n            this._backdropSubscription.unsubscribe();\n        }\n        if (this._positionSubscription) {\n            this._positionSubscription.unsubscribe();\n        }\n        if (this._detachmentsSubscription) {\n            this._detachmentsSubscription.unsubscribe();\n        }\n    }\n    _handleMousedown(event) {\n        if (event && !isFakeMousedownFromScreenReader(event)) {\n            this._openedByMouse = true;\n        }\n    }\n    static { this.ɵfac = function MdePopoverTrigger_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || MdePopoverTrigger)(i0.ɵɵdirectiveInject(i1$1.Overlay), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i2$1.Directionality, 8), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); }; }\n    static { this.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: MdePopoverTrigger, selectors: [[\"\", \"mdePopoverTriggerFor\", \"\"]], hostVars: 1, hostBindings: function MdePopoverTrigger_HostBindings(rf, ctx) { if (rf & 1) {\n            i0.ɵɵlistener(\"click\", function MdePopoverTrigger_click_HostBindingHandler($event) { return ctx.onClick($event); })(\"mouseenter\", function MdePopoverTrigger_mouseenter_HostBindingHandler($event) { return ctx.onMouseEnter($event); })(\"mouseleave\", function MdePopoverTrigger_mouseleave_HostBindingHandler($event) { return ctx.onMouseLeave($event); })(\"mousedown\", function MdePopoverTrigger_mousedown_HostBindingHandler($event) { return ctx._handleMousedown($event); });\n        } if (rf & 2) {\n            i0.ɵɵattribute(\"aria-haspopup\", ctx.ariaHaspopup);\n        } }, inputs: { popover: [0, \"mdePopoverTriggerFor\", \"popover\"], targetElement: [0, \"mdePopoverTargetAt\", \"targetElement\"], positionX: [0, \"mdePopoverPositionX\", \"positionX\"], positionY: [0, \"mdePopoverPositionY\", \"positionY\"], triggerEvent: [0, \"mdePopoverTriggerOn\", \"triggerEvent\"], enterDelay: [0, \"mdePopoverEnterDelay\", \"enterDelay\"], leaveDelay: [0, \"mdePopoverLeaveDelay\", \"leaveDelay\"], overlapTrigger: [0, \"mdePopoverOverlapTrigger\", \"overlapTrigger\"], targetOffsetX: [0, \"mdePopoverOffsetX\", \"targetOffsetX\"], targetOffsetY: [0, \"mdePopoverOffsetY\", \"targetOffsetY\"], arrowOffsetX: [0, \"mdePopoverArrowOffsetX\", \"arrowOffsetX\"], arrowWidth: [0, \"mdePopoverArrowWidth\", \"arrowWidth\"], arrowColor: [0, \"mdePopoverArrowColor\", \"arrowColor\"], closeOnClick: [0, \"mdePopoverCloseOnClick\", \"closeOnClick\"], backdropCloseOnClick: [0, \"mdePopoverBackdropCloseOnClick\", \"backdropCloseOnClick\"] }, outputs: { opened: \"opened\", closed: \"closed\" }, exportAs: [\"mdePopoverTrigger\"], standalone: false }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MdePopoverTrigger, [{\n        type: Directive,\n        args: [{\n                selector: '[mdePopoverTriggerFor]',\n                exportAs: 'mdePopoverTrigger',\n                standalone: false\n            }]\n    }], () => [{ type: i1$1.Overlay }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2$1.Directionality, decorators: [{\n                type: Optional\n            }] }, { type: i0.ChangeDetectorRef }], { ariaHaspopup: [{\n            type: HostBinding,\n            args: ['attr.aria-haspopup']\n        }], popover: [{\n            type: Input,\n            args: ['mdePopoverTriggerFor']\n        }], targetElement: [{\n            type: Input,\n            args: ['mdePopoverTargetAt']\n        }], positionX: [{\n            type: Input,\n            args: ['mdePopoverPositionX']\n        }], positionY: [{\n            type: Input,\n            args: ['mdePopoverPositionY']\n        }], triggerEvent: [{\n            type: Input,\n            args: ['mdePopoverTriggerOn']\n        }], enterDelay: [{\n            type: Input,\n            args: ['mdePopoverEnterDelay']\n        }], leaveDelay: [{\n            type: Input,\n            args: ['mdePopoverLeaveDelay']\n        }], overlapTrigger: [{\n            type: Input,\n            args: ['mdePopoverOverlapTrigger']\n        }], targetOffsetX: [{\n            type: Input,\n            args: ['mdePopoverOffsetX']\n        }], targetOffsetY: [{\n            type: Input,\n            args: ['mdePopoverOffsetY']\n        }], arrowOffsetX: [{\n            type: Input,\n            args: ['mdePopoverArrowOffsetX']\n        }], arrowWidth: [{\n            type: Input,\n            args: ['mdePopoverArrowWidth']\n        }], arrowColor: [{\n            type: Input,\n            args: ['mdePopoverArrowColor']\n        }], closeOnClick: [{\n            type: Input,\n            args: ['mdePopoverCloseOnClick']\n        }], backdropCloseOnClick: [{\n            type: Input,\n            args: ['mdePopoverBackdropCloseOnClick']\n        }], opened: [{\n            type: Output\n        }], closed: [{\n            type: Output\n        }], onClick: [{\n            type: HostListener,\n            args: ['click', ['$event']]\n        }], onMouseEnter: [{\n            type: HostListener,\n            args: ['mouseenter', ['$event']]\n        }], onMouseLeave: [{\n            type: HostListener,\n            args: ['mouseleave', ['$event']]\n        }], _handleMousedown: [{\n            type: HostListener,\n            args: ['mousedown', ['$event']]\n        }] }); })();\n\nclass MdePopoverTarget {\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    static { this.ɵfac = function MdePopoverTarget_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || MdePopoverTarget)(i0.ɵɵdirectiveInject(i0.ElementRef)); }; }\n    static { this.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: MdePopoverTarget, selectors: [[\"mde-popover-target\"], [\"\", \"mdePopoverTarget\", \"\"]], exportAs: [\"mdePopoverTarget\"], standalone: false }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MdePopoverTarget, [{\n        type: Directive,\n        args: [{\n                selector: 'mde-popover-target, [mdePopoverTarget]',\n                exportAs: 'mdePopoverTarget',\n                standalone: false\n            }]\n    }], () => [{ type: i0.ElementRef }], null); })();\n\nclass MdePopoverModule {\n    static { this.ɵfac = function MdePopoverModule_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || MdePopoverModule)(); }; }\n    static { this.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: MdePopoverModule }); }\n    static { this.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [OverlayModule,\n            CommonModule,\n            A11yModule] }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MdePopoverModule, [{\n        type: NgModule,\n        args: [{\n                imports: [\n                    OverlayModule,\n                    CommonModule,\n                    A11yModule\n                ],\n                exports: [MdePopover, MdePopoverTrigger, MdePopoverTarget],\n                declarations: [MdePopover, MdePopoverTrigger, MdePopoverTarget],\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(MdePopoverModule, { declarations: [MdePopover, MdePopoverTrigger, MdePopoverTarget], imports: [OverlayModule,\n        CommonModule,\n        A11yModule], exports: [MdePopover, MdePopoverTrigger, MdePopoverTarget] }); })();\n\n/*\n * Public API Surface of mde\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MdePopover, MdePopoverModule, MdePopoverTarget, MdePopoverTrigger, transformPopover };\n//# sourceMappingURL=material-extended-mde.mjs.map\n","map":null,"preliminaryFileName":"material-extended-mde.mjs","sourcemapFileName":"material-extended-mde.mjs.map"},{"fileName":"material-extended-mde.mjs.map","names":[],"needsCodeReference":false,"originalFileName":null,"originalFileNames":[],"source":"{\"version\":3,\"file\":\"material-extended-mde.mjs\",\"sources\":[\"../../../../projects/material-extended/mde/src/lib/popover/popover-errors.ts\",\"../../../../projects/material-extended/mde/src/lib/popover/popover-animations.ts\",\"../../../../projects/material-extended/mde/src/lib/popover/popover.html\",\"../../../../projects/material-extended/mde/src/lib/popover/popover.ts\",\"../../../../projects/material-extended/mde/src/lib/popover/popover-trigger.ts\",\"../../../../projects/material-extended/mde/src/lib/popover/popover-target.ts\",\"../../../../projects/material-extended/mde/src/lib/popover/popover-module.ts\",\"../../../../projects/material-extended/mde/src/public_api.ts\",\"../../../../projects/material-extended/mde/src/material-extended-mde.ts\"],\"sourcesContent\":[\"/**\\r\\n * Throws an exception for the case when popover trigger doesn't have a valid mde-popover instance\\r\\n */\\r\\nexport function throwMdePopoverMissingError() {\\r\\n  throw Error(`mde-popover-trigger: must pass in an mde-popover instance.\\r\\n\\r\\n    Example:\\r\\n      <mde-popover #popover=\\\"mdePopover\\\"></mde-popover>\\r\\n      <button [mdePopoverTriggerFor]=\\\"popover\\\"></button>`);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Throws an exception for the case when popover's mdePopoverPositionX value isn't valid.\\r\\n * In other words, it doesn't match 'before' or 'after'.\\r\\n */\\r\\nexport function throwMdePopoverInvalidPositionX() {\\r\\n  throw Error(`mdePopoverPositionX value must be either 'before' or after'.\\r\\n      Example: <mde-popover mdePopoverPositionX=\\\"before\\\" #popover=\\\"mdePopover\\\"></mde-popover>`);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Throws an exception for the case when popover's mdePopoverPositionY value isn't valid.\\r\\n * In other words, it doesn't match 'above' or 'below'.\\r\\n */\\r\\nexport function throwMdePopoverInvalidPositionY() {\\r\\n  throw Error(`mdePopoverPositionY value must be either 'above' or below'.\\r\\n      Example: <mde-popover mdePopoverPositionY=\\\"above\\\" #popover=\\\"mdePopover\\\"></mde-popover>`);\\r\\n}\\r\\n\",\"import {\\r\\n  trigger,\\r\\n  state,\\r\\n  style,\\r\\n  animate,\\r\\n  transition,\\r\\n  AnimationTriggerMetadata,\\r\\n} from '@angular/animations';\\r\\n\\r\\n/**\\r\\n * Below are all the animations for the md-popover component.\\r\\n * Animation duration and timing values are based on AngularJS Material.\\r\\n */\\r\\n\\r\\n/**\\r\\n * This animation controls the popover panel's entry and exit from the page.\\r\\n *\\r\\n * When the popover panel is added to the DOM, it scales in and fades in its border.\\r\\n *\\r\\n * When the popover panel is removed from the DOM, it simply fades out after a brief\\r\\n * delay to display the ripple.\\r\\n */\\r\\n\\r\\nexport const transformPopover: AnimationTriggerMetadata = trigger('transformPopover', [\\r\\n  state('enter', style({\\r\\n    opacity: 1,\\r\\n    transform: `scale(1)`\\r\\n  })),\\r\\n  transition('void => *', [\\r\\n    style({\\r\\n      opacity: 0,\\r\\n      transform: `scale(0)`\\r\\n    }),\\r\\n    animate(`200ms cubic-bezier(0.25, 0.8, 0.25, 1)`)\\r\\n  ]),\\r\\n  transition('* => void', [\\r\\n    animate('50ms 100ms linear', style({opacity: 0}))\\r\\n  ])\\r\\n]);\\r\\n\",\"<ng-template>\\r\\n  <div class=\\\"mde-popover-panel\\\" role=\\\"dialog\\\" [class.mde-popover-overlap]=\\\"overlapTrigger\\\"\\r\\n       [ngClass]=\\\"_classList\\\" [ngStyle]=\\\"popoverPanelStyles\\\" (keydown)=\\\"_handleKeydown($event)\\\"\\r\\n       (click)=\\\"onClick()\\\" (mouseover)=\\\"onMouseOver()\\\" (mouseleave)=\\\"onMouseLeave()\\\" [@.disabled]=\\\"disableAnimation\\\"\\r\\n       [@transformPopover]=\\\"'enter'\\\">\\r\\n    <div class=\\\"mde-popover-direction-arrow\\\" [ngStyle]=\\\"popoverArrowStyles\\\" *ngIf=\\\"!overlapTrigger\\\"></div>\\r\\n    <div class=\\\"mde-popover-content\\\" [ngStyle]=\\\"popoverContentStyles\\\" [cdkTrapFocus]=\\\"focusTrapEnabled\\\" [cdkTrapFocusAutoCapture]=\\\"focusTrapAutoCaptureEnabled\\\">\\r\\n      <ng-content></ng-content>\\r\\n    </div>\\r\\n  </div>\\r\\n</ng-template>\\r\\n\",\"import {\\r\\n  Component,\\r\\n  EventEmitter,\\r\\n  Input,\\r\\n  OnDestroy,\\r\\n  Output,\\r\\n  TemplateRef,\\r\\n  ViewChild,\\r\\n  ViewEncapsulation,\\r\\n  ElementRef,\\r\\n  ChangeDetectionStrategy,\\r\\n  HostBinding,\\r\\n  NgZone\\r\\n} from '@angular/core';\\r\\n\\r\\nimport { AnimationEvent } from '@angular/animations';\\r\\n\\r\\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\\r\\nimport { ESCAPE } from '@angular/cdk/keycodes';\\r\\n\\r\\nimport { MdePopoverPositionX, MdePopoverPositionY, MdePopoverTriggerEvent, MdePopoverScrollStrategy } from './popover-types';\\r\\nimport { throwMdePopoverInvalidPositionX, throwMdePopoverInvalidPositionY } from './popover-errors';\\r\\nimport { MdePopoverPanel } from './popover-interfaces';\\r\\nimport { transformPopover } from './popover-animations';\\r\\n\\r\\n@Component({\\n    selector: 'mde-popover',\\n    templateUrl: './popover.html',\\n    styleUrls: ['./popover.scss'],\\n    changeDetection: ChangeDetectionStrategy.OnPush,\\n    encapsulation: ViewEncapsulation.None,\\n    animations: [\\n        transformPopover\\n    ],\\n    exportAs: 'mdePopover',\\n    standalone: false\\n})\\r\\nexport class MdePopover implements MdePopoverPanel, OnDestroy { // tslint:disable-line:component-class-suffix\\r\\n\\r\\n  @HostBinding('attr.role') role = 'dialog';\\r\\n\\r\\n  /** Settings for popover, view setters and getters for more detail */\\r\\n  private _positionX: MdePopoverPositionX = 'after';\\r\\n  private _positionY: MdePopoverPositionY = 'below';\\r\\n  private _triggerEvent: MdePopoverTriggerEvent = 'hover';\\r\\n  private _scrollStrategy: MdePopoverScrollStrategy = 'reposition';\\r\\n  private _enterDelay = 200;\\r\\n  private _leaveDelay = 200;\\r\\n  private _overlapTrigger = true;\\r\\n  private _disableAnimation = false;\\r\\n  private _targetOffsetX = 0;\\r\\n  private _targetOffsetY = 0;\\r\\n  private _arrowOffsetX = 20;\\r\\n  private _arrowWidth = 8;\\r\\n  private _arrowColor = 'rgba(0, 0, 0, 0.12)';\\r\\n  private _closeOnClick = true;\\r\\n  private _focusTrapEnabled = true;\\r\\n  private _focusTrapAutoCaptureEnabled = true;\\r\\n\\r\\n  /** Config object to be passed into the popover's ngClass */\\r\\n  _classList: {[key: string]: boolean} = {};\\r\\n\\r\\n  // TODO: Write comment description\\r\\n  /** */\\r\\n  public containerPositioning = false;\\r\\n\\r\\n  /** Closing disabled on popover */\\r\\n  public closeDisabled = false;\\r\\n\\r\\n  /** Config object to be passed into the popover's arrow ngStyle */\\r\\n  public popoverPanelStyles: {};\\r\\n\\r\\n  /** Config object to be passed into the popover's arrow ngStyle */\\r\\n  public popoverArrowStyles: {};\\r\\n\\r\\n  /** Config object to be passed into the popover's content ngStyle */\\r\\n  public popoverContentStyles: {};\\r\\n\\r\\n  /** Emits the current animation state whenever it changes. */\\r\\n  _onAnimationStateChange = new EventEmitter<AnimationEvent>();\\r\\n\\r\\n\\r\\n  /** Position of the popover in the X axis. */\\r\\n  @Input('mdePopoverPositionX')\\r\\n  get positionX() { return this._positionX; }\\r\\n  set positionX(value: MdePopoverPositionX) {\\r\\n    if (value !== 'before' && value !== 'after') {\\r\\n      throwMdePopoverInvalidPositionX();\\r\\n    }\\r\\n    this._positionX = value;\\r\\n    this.setPositionClasses();\\r\\n  }\\r\\n\\r\\n  /** Position of the popover in the Y axis. */\\r\\n  @Input('mdePopoverPositionY')\\r\\n  get positionY() { return this._positionY; }\\r\\n  set positionY(value: MdePopoverPositionY) {\\r\\n    if (value !== 'above' && value !== 'below') {\\r\\n      throwMdePopoverInvalidPositionY();\\r\\n    }\\r\\n    this._positionY = value;\\r\\n    this.setPositionClasses();\\r\\n  }\\r\\n\\r\\n  /** Popover trigger event */\\r\\n  @Input('mdePopoverTriggerOn')\\r\\n  get triggerEvent(): MdePopoverTriggerEvent { return this._triggerEvent; }\\r\\n  set triggerEvent(value: MdePopoverTriggerEvent) { this._triggerEvent = value; }\\r\\n\\r\\n  /** Popover scroll strategy */\\r\\n  @Input('mdePopoverScrollStrategy')\\r\\n  get scrollStrategy(): MdePopoverScrollStrategy { return this._scrollStrategy; }\\r\\n  set scrollStrategy(value: MdePopoverScrollStrategy) { this._scrollStrategy = value; }\\r\\n\\r\\n  /** Popover enter delay */\\r\\n  @Input('mdePopoverEnterDelay')\\r\\n  get enterDelay(): number { return this._enterDelay; }\\r\\n  set enterDelay(value: number) { this._enterDelay = value; }\\r\\n\\r\\n  /** Popover leave delay */\\r\\n  @Input('mdePopoverLeaveDelay')\\r\\n  get leaveDelay(): number { return this._leaveDelay; }\\r\\n  set leaveDelay(value: number) { this._leaveDelay = value; }\\r\\n\\r\\n  /** Popover overlap trigger */\\r\\n  @Input('mdePopoverOverlapTrigger')\\r\\n  get overlapTrigger(): boolean { return this._overlapTrigger; }\\r\\n  set overlapTrigger(value: boolean) { this._overlapTrigger = value; }\\r\\n\\r\\n  /** Popover target offset x */\\r\\n  @Input('mdePopoverOffsetX')\\r\\n  get targetOffsetX(): number { return this._targetOffsetX; }\\r\\n  set targetOffsetX(value: number) { this._targetOffsetX = value; }\\r\\n\\r\\n  /** Popover target offset y */\\r\\n  @Input('mdePopoverOffsetY')\\r\\n  get targetOffsetY(): number { return this._targetOffsetY; }\\r\\n  set targetOffsetY(value: number) { this._targetOffsetY = value; }\\r\\n\\r\\n  /** Popover arrow offset x */\\r\\n  @Input('mdePopoverArrowOffsetX')\\r\\n  get arrowOffsetX(): number { return this._arrowOffsetX; }\\r\\n  set arrowOffsetX(value: number) { this._arrowOffsetX = value; }\\r\\n\\r\\n  /** Popover arrow width */\\r\\n  @Input('mdePopoverArrowWidth')\\r\\n  get arrowWidth(): number { return this._arrowWidth; }\\r\\n  set arrowWidth(value: number) { this._arrowWidth = value; }\\r\\n\\r\\n  /** Popover arrow color */\\r\\n  @Input('mdePopoverArrowColor')\\r\\n  get arrowColor(): string { return this._arrowColor; }\\r\\n  set arrowColor(value: string) { this._arrowColor = value; }\\r\\n\\r\\n  /**\\r\\n   * Popover container close on click\\r\\n   * default: true\\r\\n   */\\r\\n  @Input('mdePopoverCloseOnClick')\\r\\n  get closeOnClick(): boolean { return this._closeOnClick; }\\r\\n  set closeOnClick(value: boolean) { this._closeOnClick = coerceBooleanProperty(value); }\\r\\n\\r\\n  /**\\r\\n   * Disable animations of popover and all child elements\\r\\n   * default: false\\r\\n   */\\r\\n  @Input('mdePopoverDisableAnimation')\\r\\n  get disableAnimation(): boolean { return this._disableAnimation; }\\r\\n  set disableAnimation(value: boolean) { this._disableAnimation = coerceBooleanProperty(value); }\\r\\n\\r\\n  /**\\r\\n   * Popover focus trap using cdkTrapFocus\\r\\n   * default: true\\r\\n   */\\r\\n  @Input('mdeFocusTrapEnabled')\\r\\n  get focusTrapEnabled(): boolean { return this._focusTrapEnabled; }\\r\\n  set focusTrapEnabled(value: boolean) { this._focusTrapEnabled = coerceBooleanProperty(value); }\\r\\n\\r\\n  /**\\r\\n   * Popover focus trap auto capture using cdkTrapFocusAutoCapture\\r\\n   * default: true\\r\\n   */\\r\\n  @Input('mdeFocusTrapAutoCaptureEnabled')\\r\\n  get focusTrapAutoCaptureEnabled(): boolean { return this._focusTrapAutoCaptureEnabled; }\\r\\n  set focusTrapAutoCaptureEnabled(value: boolean) { this._focusTrapAutoCaptureEnabled = coerceBooleanProperty(value); }\\r\\n\\r\\n  /**\\r\\n   * This method takes classes set on the host md-popover element and applies them on the\\r\\n   * popover template that displays in the overlay container.  Otherwise, it's difficult\\r\\n   * to style the containing popover from outside the component.\\r\\n   * @param classes list of class names\\r\\n   */\\r\\n  @Input('class')\\r\\n  set panelClass(classes: string) {\\r\\n    if (classes && classes.length) {\\r\\n      this._classList = classes.split(' ').reduce((obj: any, className: string) => {\\r\\n        obj[className] = true;\\r\\n        return obj;\\r\\n      }, {});\\r\\n\\r\\n      this._elementRef.nativeElement.className = '';\\r\\n      this.setPositionClasses();\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * This method takes classes set on the host md-popover element and applies them on the\\r\\n   * popover template that displays in the overlay container.  Otherwise, it's difficult\\r\\n   * to style the containing popover from outside the component.\\r\\n   * @deprecated Use `panelClass` instead.\\r\\n   */\\r\\n  @Input()\\r\\n  get classList(): string { return this.panelClass; }\\r\\n  set classList(classes: string) { this.panelClass = classes; }\\r\\n\\r\\n  /** Event emitted when the popover is closed. */\\r\\n  @Output() close = new EventEmitter<void>();\\r\\n\\r\\n  @ViewChild(TemplateRef) templateRef: TemplateRef<any>;\\r\\n\\r\\n  constructor(private _elementRef: ElementRef, public zone: NgZone) {\\r\\n    this.setPositionClasses();\\r\\n  }\\r\\n\\r\\n  ngOnDestroy() {\\r\\n    this._emitCloseEvent();\\r\\n    this.close.complete();\\r\\n  }\\r\\n\\r\\n\\r\\n  /** Handle a keyboard event from the popover, delegating to the appropriate action. */\\r\\n  _handleKeydown(event: KeyboardEvent) {\\r\\n    switch (event.keyCode) {\\r\\n      case ESCAPE:\\r\\n        this._emitCloseEvent();\\r\\n        return;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * This emits a close event to which the trigger is subscribed. When emitted, the\\r\\n   * trigger will close the popover.\\r\\n   */\\r\\n  _emitCloseEvent(): void {\\r\\n    this.close.emit();\\r\\n  }\\r\\n\\r\\n  /** Close popover on click if closeOnClick is true */\\r\\n  onClick() {\\r\\n    if (this.closeOnClick) {\\r\\n      this._emitCloseEvent();\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * TODO: Refactor when @angular/cdk includes feature I mentioned on github see link below.\\r\\n   * https://github.com/angular/material2/pull/5493#issuecomment-313085323\\r\\n   */\\r\\n  /** Disables close of popover when leaving trigger element and mouse over the popover */\\r\\n  onMouseOver() {\\r\\n    if (this.triggerEvent === 'hover') {\\r\\n      this.closeDisabled = true;\\r\\n    }\\r\\n  }\\r\\n  /** Enables close of popover when mouse leaving popover element */\\r\\n  onMouseLeave() {\\r\\n    if (this.triggerEvent === 'hover') {\\r\\n      this.closeDisabled = false;\\r\\n      this._emitCloseEvent();\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // TODO: Refactor how styles are set and updated on the component, use best practices.\\r\\n  // TODO: If arrow left and right positioning is requested, see if flex direction can be used to work with order.\\r\\n  /** Sets the current styles for the popover to allow for dynamically changing settings */\\r\\n  setCurrentStyles() {\\r\\n\\r\\n    // TODO: See if arrow position can be calculated automatically and allow override.\\r\\n    // TODO: See if flex order is a better alternative to position arrow top or bottom.\\r\\n    this.popoverArrowStyles = {\\r\\n      'right': this.positionX === 'before' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',\\r\\n      'left': this.positionX === 'after' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',\\r\\n      'border-top': this.positionY === 'below' ?\\r\\n        this.arrowWidth + 'px solid ' + this.arrowColor : '0px solid transparent',\\r\\n      'border-right': 'undefined' === undefined ?\\r\\n        this.arrowWidth + 'px solid ' + this.arrowColor :\\r\\n        this.arrowWidth + 'px solid transparent',\\r\\n      'border-bottom': this.positionY === 'above' ?\\r\\n        this.arrowWidth + 'px solid ' + this.arrowColor :\\r\\n        this.arrowWidth + 'px solid transparent',\\r\\n      'border-left': 'undefined' === undefined ?\\r\\n        this.arrowWidth + 'px solid ' + this.arrowColor :\\r\\n        this.arrowWidth + 'px solid transparent',\\r\\n    };\\r\\n\\r\\n    // TODO: Remove if flex order is added.\\r\\n    this.popoverContentStyles = {\\r\\n      'padding-top': this.overlapTrigger === true ? '0px' : this.arrowWidth + 'px',\\r\\n      'padding-bottom': this.overlapTrigger === true ? '0px' : (this.arrowWidth) + 'px',\\r\\n      'margin-top': this.overlapTrigger === false && this.positionY === 'below' && this.containerPositioning === false ?\\r\\n        -(this.arrowWidth * 2) + 'px' : '0px'\\r\\n    };\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * It's necessary to set position-based classes to ensure the popover panel animation\\r\\n   * folds out from the correct direction.\\r\\n   */\\r\\n  setPositionClasses(posX = this.positionX, posY = this.positionY): void {\\r\\n    this._classList['mde-popover-before'] = posX === 'before';\\r\\n    this._classList['mde-popover-after'] = posX === 'after';\\r\\n    this._classList['mde-popover-above'] = posY === 'above';\\r\\n    this._classList['mde-popover-below'] = posY === 'below';\\r\\n  }\\r\\n}\\r\\n\",\"import {\\r\\n  AfterViewInit,\\r\\n  Directive,\\r\\n  ElementRef,\\r\\n  EventEmitter,\\r\\n  Input,\\r\\n  OnDestroy,\\r\\n  Optional,\\r\\n  Output,\\r\\n  ViewContainerRef,\\r\\n  HostListener,\\r\\n  HostBinding,\\r\\n  ChangeDetectorRef,\\r\\n} from '@angular/core';\\r\\n\\r\\nimport { isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\\r\\nimport { Direction, Directionality } from '@angular/cdk/bidi';\\r\\nimport {\\r\\n  Overlay,\\r\\n  OverlayRef,\\r\\n  OverlayConfig,\\r\\n  HorizontalConnectionPos,\\r\\n  VerticalConnectionPos,\\r\\n  FlexibleConnectedPositionStrategy,\\r\\n  ScrollStrategy\\r\\n} from '@angular/cdk/overlay';\\r\\nimport { TemplatePortal } from '@angular/cdk/portal';\\r\\n\\r\\nimport { Subscription, Subject } from 'rxjs';\\r\\n\\r\\nimport { MdePopoverPanel, MdeTarget } from './popover-interfaces';\\r\\nimport { MdePopoverPositionX, MdePopoverPositionY, MdePopoverTriggerEvent, MdePopoverScrollStrategy } from './popover-types';\\r\\nimport { throwMdePopoverMissingError } from './popover-errors';\\r\\nimport { takeUntil } from 'rxjs/operators';\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * This directive is intended to be used in conjunction with an mde-popover tag. It is\\r\\n * responsible for toggling the display of the provided popover instance.\\r\\n */\\r\\n\\r\\n@Directive({\\n    selector: '[mdePopoverTriggerFor]',\\n    exportAs: 'mdePopoverTrigger',\\n    standalone: false\\n})\\r\\nexport class MdePopoverTrigger implements AfterViewInit, OnDestroy { // tslint:disable-line:directive-class-suffix\\r\\n\\r\\n    @HostBinding('attr.aria-haspopup') ariaHaspopup = true;\\r\\n\\r\\n    popoverOpened = new Subject<void>();\\r\\n    popoverClosed = new Subject<void>();\\r\\n\\r\\n    private _portal: TemplatePortal<any>;\\r\\n    private _overlayRef: OverlayRef | null = null;\\r\\n    private _popoverOpen = false;\\r\\n    private _halt = false;\\r\\n    private _backdropSubscription: Subscription;\\r\\n    private _positionSubscription: Subscription;\\r\\n    private _detachmentsSubscription: Subscription;\\r\\n\\r\\n    private _mouseoverTimer: any;\\r\\n\\r\\n    // tracking input type is necessary so it's possible to only auto-focus\\r\\n    // the first item of the list when the popover is opened via the keyboard\\r\\n    private _openedByMouse = false;\\r\\n\\r\\n    private _onDestroy = new Subject<void>();\\r\\n\\r\\n    /** References the popover instance that the trigger is associated with. */\\r\\n    @Input('mdePopoverTriggerFor') popover: MdePopoverPanel;\\r\\n\\r\\n    /** References the popover target instance that the trigger is associated with. */\\r\\n    @Input('mdePopoverTargetAt') targetElement: MdeTarget;\\r\\n\\r\\n    /** Position of the popover in the X axis */\\r\\n    @Input('mdePopoverPositionX') positionX: MdePopoverPositionX;\\r\\n\\r\\n    /** Position of the popover in the Y axis */\\r\\n    @Input('mdePopoverPositionY') positionY: MdePopoverPositionY;\\r\\n\\r\\n    /** Popover trigger event */\\r\\n    @Input('mdePopoverTriggerOn') triggerEvent: MdePopoverTriggerEvent;\\r\\n\\r\\n    /** Popover delay */\\r\\n    @Input('mdePopoverEnterDelay') enterDelay: number;\\r\\n\\r\\n    /** Popover delay */\\r\\n    @Input('mdePopoverLeaveDelay') leaveDelay: number;\\r\\n\\r\\n    /** Popover overlap trigger */\\r\\n    @Input('mdePopoverOverlapTrigger') overlapTrigger: boolean;\\r\\n\\r\\n    /** Popover target offset x */\\r\\n    @Input('mdePopoverOffsetX') targetOffsetX: number;\\r\\n\\r\\n    /** Popover target offset y */\\r\\n    @Input('mdePopoverOffsetY') targetOffsetY: number;\\r\\n\\r\\n    /** Popover arrow offset x */\\r\\n    @Input('mdePopoverArrowOffsetX') arrowOffsetX: number;\\r\\n\\r\\n\\r\\n    /** Popover arrow width */\\r\\n    @Input('mdePopoverArrowWidth') arrowWidth: number;\\r\\n\\r\\n\\r\\n    /** Popover arrow color */\\r\\n    @Input('mdePopoverArrowColor') arrowColor: string;\\r\\n\\r\\n\\r\\n    /** Popover container close on click */\\r\\n    @Input('mdePopoverCloseOnClick') closeOnClick: boolean;\\r\\n\\r\\n\\r\\n    /** Popover backdrop close on click */\\r\\n    @Input('mdePopoverBackdropCloseOnClick') backdropCloseOnClick = true;\\r\\n\\r\\n    /** Event emitted when the associated popover is opened. */\\r\\n    @Output() opened = new EventEmitter<void>();\\r\\n\\r\\n    /** Event emitted when the associated popover is closed. */\\r\\n    @Output() closed = new EventEmitter<void>();\\r\\n\\r\\n\\r\\n    constructor(private _overlay: Overlay, public _elementRef: ElementRef,\\r\\n              private _viewContainerRef: ViewContainerRef,\\r\\n              @Optional() private _dir: Directionality,\\r\\n              private _changeDetectorRef: ChangeDetectorRef) { }\\r\\n\\r\\n    ngAfterViewInit() {\\r\\n        this._checkPopover();\\r\\n        this._setCurrentConfig();\\r\\n        this.popover.close.subscribe(() => this.closePopover());\\r\\n    }\\r\\n\\r\\n    ngOnDestroy() {\\r\\n      this.destroyPopover();\\r\\n    }\\r\\n\\r\\n    private _setCurrentConfig() {\\r\\n\\r\\n        if (this.positionX === 'before' || this.positionX === 'after') {\\r\\n          this.popover.positionX = this.positionX;\\r\\n        }\\r\\n\\r\\n        if (this.positionY === 'above' || this.positionY === 'below') {\\r\\n          this.popover.positionY = this.positionY;\\r\\n        }\\r\\n\\r\\n        if (this.triggerEvent) {\\r\\n            this.popover.triggerEvent = this.triggerEvent;\\r\\n        }\\r\\n\\r\\n        if (this.enterDelay) {\\r\\n          this.popover.enterDelay = this.enterDelay;\\r\\n        }\\r\\n\\r\\n        if (this.leaveDelay) {\\r\\n          this.popover.leaveDelay = this.leaveDelay;\\r\\n        }\\r\\n\\r\\n        if (this.overlapTrigger === true || this.overlapTrigger === false) {\\r\\n            this.popover.overlapTrigger = this.overlapTrigger;\\r\\n        }\\r\\n\\r\\n        if (this.targetOffsetX) {\\r\\n            this.popover.targetOffsetX = this.targetOffsetX;\\r\\n        }\\r\\n\\r\\n        if (this.targetOffsetY) {\\r\\n            this.popover.targetOffsetY = this.targetOffsetY;\\r\\n        }\\r\\n\\r\\n        if (this.arrowOffsetX) {\\r\\n            this.popover.arrowOffsetX = this.arrowOffsetX;\\r\\n        }\\r\\n\\r\\n        if (this.arrowWidth) {\\r\\n            this.popover.arrowWidth = this.arrowWidth;\\r\\n        }\\r\\n\\r\\n        if (this.arrowColor) {\\r\\n            this.popover.arrowColor = this.arrowColor;\\r\\n        }\\r\\n\\r\\n        if (this.closeOnClick === true || this.closeOnClick === false) {\\r\\n            this.popover.closeOnClick = this.closeOnClick;\\r\\n        }\\r\\n\\r\\n        this.popover.setCurrentStyles();\\r\\n    }\\r\\n\\r\\n\\r\\n    /** Whether the popover is open. */\\r\\n    get popoverOpen(): boolean { return this._popoverOpen; }\\r\\n\\r\\n    @HostListener('click', ['$event'])\\r\\n    onClick(event: MouseEvent): void {\\r\\n      if (this.popover.triggerEvent === 'click') {\\r\\n        this.togglePopover();\\r\\n      }\\r\\n    }\\r\\n\\r\\n    @HostListener('mouseenter', ['$event'])\\r\\n    onMouseEnter(event: MouseEvent): void {\\r\\n      this._halt = false;\\r\\n      if (this.popover.triggerEvent === 'hover') {\\r\\n        this._mouseoverTimer = setTimeout(() => {\\r\\n          this.openPopover();\\r\\n        }, this.popover.enterDelay);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    @HostListener('mouseleave', ['$event'])\\r\\n    onMouseLeave(event: MouseEvent): void {\\r\\n      if (this.popover.triggerEvent === 'hover') {\\r\\n        if (this._mouseoverTimer) {\\r\\n          clearTimeout(this._mouseoverTimer);\\r\\n          this._mouseoverTimer = null;\\r\\n        }\\r\\n        if (this._popoverOpen) {\\r\\n          setTimeout(() => {\\r\\n            if (!this.popover.closeDisabled) {\\r\\n                this.closePopover();\\r\\n            }\\r\\n          }, this.popover.leaveDelay);\\r\\n        } else {\\r\\n          this._halt = true;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    /** Toggles the popover between the open and closed states. */\\r\\n    togglePopover(): void {\\r\\n        return this._popoverOpen ? this.closePopover() : this.openPopover();\\r\\n    }\\r\\n\\r\\n    /** Opens the popover. */\\r\\n    openPopover(): void {\\r\\n        if (!this._popoverOpen && !this._halt) {\\r\\n            this._createOverlay().attach(this._portal);\\r\\n    \\r\\n            this._subscribeToBackdrop();\\r\\n            this._subscribeToDetachments();\\r\\n\\r\\n            this._initPopover();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** Closes the popover. */\\r\\n    closePopover(): void {\\r\\n        if (this._overlayRef) {\\r\\n          this._overlayRef.detach();\\r\\n          this._resetPopover();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** Removes the popover from the DOM. */\\r\\n    destroyPopover(): void {\\r\\n        if (this._mouseoverTimer) {\\r\\n            clearTimeout(this._mouseoverTimer);\\r\\n            this._mouseoverTimer = null;\\r\\n        }\\r\\n        if (this._overlayRef) {\\r\\n          this._overlayRef.dispose();\\r\\n          this._overlayRef = null;\\r\\n          this._cleanUpSubscriptions();\\r\\n        }\\r\\n\\r\\n        this._onDestroy.next();\\r\\n        this._onDestroy.complete();\\r\\n    }\\r\\n\\r\\n    /** Focuses the popover trigger. */\\r\\n    focus() {\\r\\n        this._elementRef.nativeElement.focus();\\r\\n    }\\r\\n\\r\\n    /** The text direction of the containing app. */\\r\\n    get dir(): Direction {\\r\\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * This method ensures that the popover closes when the overlay backdrop is clicked.\\r\\n    * We do not use first() here because doing so would not catch clicks from within\\r\\n    * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe\\r\\n    * explicitly when the popover is closed or destroyed.\\r\\n    */\\r\\n    private _subscribeToBackdrop(): void {\\r\\n      if (this._overlayRef) {\\r\\n        /** Only subscribe to backdrop if trigger event is click */\\r\\n        if (this.triggerEvent === 'click' && this.backdropCloseOnClick === true) {\\r\\n          this._overlayRef.backdropClick()\\r\\n          .pipe(\\r\\n            takeUntil(this.popoverClosed),\\r\\n            takeUntil(this._onDestroy),\\r\\n          )\\r\\n          .subscribe(() => {\\r\\n            this.popover._emitCloseEvent();\\r\\n          });\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    private _subscribeToDetachments(): void {\\r\\n      if (this._overlayRef) {\\r\\n        this._overlayRef.detachments()\\r\\n          .pipe(\\r\\n            takeUntil(this.popoverClosed),\\r\\n            takeUntil(this._onDestroy),\\r\\n          )\\r\\n          .subscribe(() => {\\r\\n            this._setPopoverClosed();\\r\\n          });\\r\\n      }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * This method sets the popover state to open and focuses the first item if\\r\\n    * the popover was opened via the keyboard.\\r\\n    */\\r\\n    private _initPopover(): void {\\r\\n        this._setPopoverOpened();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * This method resets the popover when it's closed, most importantly restoring\\r\\n    * focus to the popover trigger if the popover was opened via the keyboard.\\r\\n    */\\r\\n    private _resetPopover(): void {\\r\\n        this._setPopoverClosed();\\r\\n\\r\\n        // Focus only needs to be reset to the host element if the popover was opened\\r\\n        // by the keyboard and manually shifted to the first popover item.\\r\\n        if (!this._openedByMouse) {\\r\\n          this.focus();\\r\\n        }\\r\\n        this._openedByMouse = false;\\r\\n    }\\r\\n\\r\\n    /** set state rather than toggle to support triggers sharing a popover */\\r\\n    private _setPopoverOpened(): void {\\r\\n      if (!this._popoverOpen) {\\r\\n        this._popoverOpen = true;\\r\\n        \\r\\n        this.popoverOpened.next();\\r\\n        this.opened.emit()\\r\\n      }\\r\\n    }\\r\\n\\r\\n    /** set state rather than toggle to support triggers sharing a popover */\\r\\n    private _setPopoverClosed(): void {\\r\\n      if (this._popoverOpen) {\\r\\n        this._popoverOpen = false;\\r\\n        \\r\\n        this.popoverClosed.next();\\r\\n        this.closed.emit();\\r\\n      }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    *  This method checks that a valid instance of MdPopover has been passed into\\r\\n    *  mdPopoverTriggerFor. If not, an exception is thrown.\\r\\n    */\\r\\n    private _checkPopover() {\\r\\n        if (!this.popover) {\\r\\n          throwMdePopoverMissingError();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    *  This method creates the overlay from the provided popover's template and saves its\\r\\n    *  OverlayRef so that it can be attached to the DOM when openPopover is called.\\r\\n    */\\r\\n    private _createOverlay(): OverlayRef {\\r\\n        if (!this._overlayRef) {\\r\\n          this._portal = new TemplatePortal(this.popover.templateRef, this._viewContainerRef);\\r\\n          const config = this._getOverlayConfig();\\r\\n          this._subscribeToPositions(config.positionStrategy as FlexibleConnectedPositionStrategy);\\r\\n          this._overlayRef = this._overlay.create(config);\\r\\n        }\\r\\n\\r\\n        return this._overlayRef;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * This method builds the configuration object needed to create the overlay, the OverlayConfig.\\r\\n    * @returns OverlayConfig\\r\\n    */\\r\\n    private _getOverlayConfig(): OverlayConfig {\\r\\n        const overlayState = new OverlayConfig();\\r\\n        overlayState.positionStrategy = this._getPosition();\\r\\n\\r\\n        /** Display overlay backdrop if trigger event is click */\\r\\n        if (this.triggerEvent === 'click') {\\r\\n          overlayState.hasBackdrop = true;\\r\\n          overlayState.backdropClass = 'cdk-overlay-transparent-backdrop';\\r\\n        }\\r\\n\\r\\n        overlayState.direction = this.dir;\\r\\n        overlayState.scrollStrategy = this._getOverlayScrollStrategy(this.popover.scrollStrategy);\\r\\n\\r\\n        return overlayState;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * This method returns the scroll strategy used by the cdk/overlay.\\r\\n     */\\r\\n    private _getOverlayScrollStrategy(strategy: MdePopoverScrollStrategy): ScrollStrategy {\\r\\n      switch(strategy) {\\r\\n        case 'noop':\\r\\n          return this._overlay.scrollStrategies.noop();\\r\\n        case 'close':\\r\\n          return this._overlay.scrollStrategies.close();\\r\\n        case 'block':\\r\\n          return this._overlay.scrollStrategies.block();\\r\\n        case 'reposition':\\r\\n        default:\\r\\n          return this._overlay.scrollStrategies.reposition();\\r\\n      }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * Listens to changes in the position of the overlay and sets the correct classes\\r\\n    * on the popover based on the new position. This ensures the animation origin is always\\r\\n    * correct, even if a fallback position is used for the overlay.\\r\\n    */\\r\\n    private _subscribeToPositions(position: FlexibleConnectedPositionStrategy): void {\\r\\n        this._positionSubscription = position.positionChanges.subscribe(change => {\\r\\n            const posisionX: MdePopoverPositionX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\\r\\n            let posisionY: MdePopoverPositionY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';\\r\\n\\r\\n            if (!this.popover.overlapTrigger) {\\r\\n                posisionY = posisionY === 'below' ? 'above' : 'below';\\r\\n            }\\r\\n\\r\\n            // required for ChangeDetectionStrategy.OnPush\\r\\n            this._changeDetectorRef.markForCheck();\\r\\n\\r\\n            this.popover.zone.run(() => {\\r\\n                this.popover.positionX = posisionX;\\r\\n                this.popover.positionY = posisionY;\\r\\n                this.popover.setCurrentStyles();\\r\\n\\r\\n                this.popover.setPositionClasses(posisionX, posisionY);\\r\\n            });\\r\\n        });\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * This method builds the position strategy for the overlay, so the popover is properly connected\\r\\n    * to the trigger.\\r\\n    * @returns ConnectedPositionStrategy\\r\\n    */\\r\\n    private _getPosition(): FlexibleConnectedPositionStrategy {\\r\\n        const [originX, originFallbackX]: HorizontalConnectionPos[] =\\r\\n          this.popover.positionX === 'before' ? ['end', 'start'] : ['start', 'end'];\\r\\n\\r\\n        const [overlayY, overlayFallbackY]: VerticalConnectionPos[] =\\r\\n          this.popover.positionY === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];\\r\\n\\r\\n        // let originY = overlayY;\\r\\n        // let fallbackOriginY = overlayFallbackY;\\r\\n\\r\\n        let originY = overlayY;\\r\\n        let originFallbackY = overlayFallbackY;\\r\\n\\r\\n        const overlayX = originX;\\r\\n        const overlayFallbackX = originFallbackX;\\r\\n\\r\\n        // let [originY, originFallbackY] = [overlayY, overlayFallbackY];\\r\\n        // let [overlayX, overlayFallbackX] = [originX, originFallbackX];\\r\\n\\r\\n        /** Reverse overlayY and fallbackOverlayY when overlapTrigger is false */\\r\\n        if (!this.popover.overlapTrigger) {\\r\\n          originY = overlayY === 'top' ? 'bottom' : 'top';\\r\\n          originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\\r\\n        }\\r\\n\\r\\n        let offsetX = 0;\\r\\n        let offsetY = 0;\\r\\n\\r\\n        if (this.popover.targetOffsetX && !isNaN(Number(this.popover.targetOffsetX))) {\\r\\n          offsetX = Number(this.popover.targetOffsetX);\\r\\n          // offsetX = -16;\\r\\n        }\\r\\n\\r\\n        if (this.popover.targetOffsetY && !isNaN(Number(this.popover.targetOffsetY))) {\\r\\n          offsetY = Number(this.popover.targetOffsetY);\\r\\n          // offsetY = -10;\\r\\n        }\\r\\n\\r\\n        /**\\r\\n         * For overriding position element, when mdePopoverTargetAt has a valid element reference.\\r\\n         * Useful for sticking popover to parent element and offsetting arrow to trigger element.\\r\\n         * If undefined defaults to the trigger element reference.\\r\\n         */\\r\\n        let element = this._elementRef;\\r\\n        if (typeof this.targetElement !== 'undefined') {\\r\\n            this.popover.containerPositioning = true;\\r\\n            element = this.targetElement._elementRef;\\r\\n        }\\r\\n\\r\\n        return this._overlay.position()\\r\\n          .flexibleConnectedTo(element)\\r\\n          .withLockedPosition(true)\\r\\n          .withPositions([\\r\\n            {\\r\\n                originX,\\r\\n                originY,\\r\\n                overlayX,\\r\\n                overlayY,\\r\\n                offsetY\\r\\n            },\\r\\n            {\\r\\n                originX: originFallbackX,\\r\\n                originY,\\r\\n                overlayX: overlayFallbackX,\\r\\n                overlayY,\\r\\n                offsetY\\r\\n            },\\r\\n            {\\r\\n              originX,\\r\\n              originY: originFallbackY,\\r\\n              overlayX,\\r\\n              overlayY: overlayFallbackY,\\r\\n              offsetY: -offsetY\\r\\n            },\\r\\n            {\\r\\n              originX: originFallbackX,\\r\\n              originY: originFallbackY,\\r\\n              overlayX: overlayFallbackX,\\r\\n              overlayY: overlayFallbackY,\\r\\n              offsetY: -offsetY\\r\\n            }\\r\\n          ])\\r\\n          .withDefaultOffsetX(offsetX)\\r\\n          .withDefaultOffsetY(offsetY);\\r\\n    }\\r\\n\\r\\n    private _cleanUpSubscriptions(): void {\\r\\n        if (this._backdropSubscription) {\\r\\n            this._backdropSubscription.unsubscribe();\\r\\n        }\\r\\n        if (this._positionSubscription) {\\r\\n            this._positionSubscription.unsubscribe();\\r\\n        }\\r\\n        if (this._detachmentsSubscription) {\\r\\n          this._detachmentsSubscription.unsubscribe();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    @HostListener('mousedown', ['$event']) _handleMousedown(event: MouseEvent): void {\\r\\n        if (event && !isFakeMousedownFromScreenReader(event)) {\\r\\n            this._openedByMouse = true;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"import { Directive, ElementRef } from '@angular/core';\\r\\n\\r\\n\\r\\n@Directive({\\n    selector: 'mde-popover-target, [mdePopoverTarget]',\\n    exportAs: 'mdePopoverTarget',\\n    standalone: false\\n})\\r\\nexport class MdePopoverTarget { // tslint:disable-line:directive-class-suffix\\r\\n\\r\\n  constructor(public _elementRef: ElementRef) { }\\r\\n\\r\\n}\\r\\n\",\"import { NgModule } from '@angular/core';\\r\\nimport { CommonModule } from '@angular/common';\\r\\n\\r\\nimport { OverlayModule } from '@angular/cdk/overlay';\\r\\n\\r\\nimport { MdePopover } from './popover';\\r\\nimport { MdePopoverTrigger } from './popover-trigger';\\r\\nimport { MdePopoverTarget } from './popover-target';\\r\\nimport { A11yModule } from '@angular/cdk/a11y';\\r\\n\\r\\n@NgModule({\\r\\n  imports: [\\r\\n    OverlayModule,\\r\\n    CommonModule,\\r\\n    A11yModule\\r\\n  ],\\r\\n  exports: [MdePopover, MdePopoverTrigger, MdePopoverTarget],\\r\\n  declarations: [MdePopover, MdePopoverTrigger, MdePopoverTarget],\\r\\n})\\r\\nexport class MdePopoverModule {}\\r\\n\",\"/*\\r\\n * Public API Surface of mde\\r\\n */\\r\\n\\r\\nexport * from './lib/popover/popover-module';\\r\\nexport * from './lib/popover/popover';\\r\\nexport * from './lib/popover/popover-animations';\\r\\nexport * from './lib/popover/popover-interfaces';\\r\\nexport * from './lib/popover/popover-trigger';\\r\\nexport * from './lib/popover/popover-target';\\r\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public_api';\\n\"],\"names\":[\"i1\",\"i2\"],\"mappings\":\"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\"}","type":"asset"}]}